{"ast":null,"code":"/*! @azure/msal-common v6.1.0 2022-02-08 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __assign, __spreadArrays } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.js';\nimport { PromptValue, Separators, AADServerParamKeys, AuthenticationScheme, GrantType } from '../utils/Constants.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { UrlString } from '../url/UrlString.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { buildClientInfoFromHomeAccountId, buildClientInfo } from '../account/ClientInfo.js';\nimport { CcsCredentialType } from '../account/CcsCredential.js';\nimport { ClientConfigurationError } from '../error/ClientConfigurationError.js';\nimport { RequestValidator } from '../request/RequestValidator.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Oauth2.0 Authorization Code client\r\n */\n\nvar AuthorizationCodeClient =\n/** @class */\nfunction (_super) {\n  __extends(AuthorizationCodeClient, _super);\n\n  function AuthorizationCodeClient(configuration) {\n    var _this = _super.call(this, configuration) || this; // Flag to indicate if client is for hybrid spa auth code redemption\n\n\n    _this.includeRedirectUri = true;\n    return _this;\n  }\n  /**\r\n   * Creates the URL of the authorization request letting the user input credentials and consent to the\r\n   * application. The URL target the /authorize endpoint of the authority configured in the\r\n   * application object.\r\n   *\r\n   * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\r\n   * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\r\n   * acquireToken(AuthorizationCodeRequest)\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.getAuthCodeUrl = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var queryString;\n      return __generator(this, function (_a) {\n        queryString = this.createAuthCodeUrlQueryString(request);\n        return [2\n        /*return*/\n        , UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString)];\n      });\n    });\n  };\n  /**\r\n   * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\r\n   * authorization_code_grant\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.acquireToken = function (request, authCodePayload) {\n    return __awaiter(this, void 0, void 0, function () {\n      var reqTimestamp, response, responseHandler;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.info(\"in acquireToken call\");\n\n            if (!request || StringUtils.isEmpty(request.code)) {\n              throw ClientAuthError.createTokenRequestCannotBeMadeError();\n            }\n\n            reqTimestamp = TimeUtils.nowSeconds();\n            return [4\n            /*yield*/\n            , this.executeTokenRequest(this.authority, request)];\n\n          case 1:\n            response = _a.sent();\n            responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin); // Validate response. This function throws a server error if an error is returned by the server.\n\n            responseHandler.validateTokenResponse(response.body);\n            return [4\n            /*yield*/\n            , responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, authCodePayload)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Handles the hash fragment response from public client code request. Returns a code response used by\r\n   * the client to exchange for a token in acquireToken.\r\n   * @param hashFragment\r\n   */\n\n\n  AuthorizationCodeClient.prototype.handleFragmentResponse = function (hashFragment, cachedState) {\n    // Handle responses.\n    var responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null); // Deserialize hash fragment response parameters.\n\n    var hashUrlString = new UrlString(hashFragment); // Deserialize hash fragment response parameters.\n\n    var serverParams = UrlString.getDeserializedHash(hashUrlString.getHash()); // Get code response\n\n    responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils); // throw when there is no auth code in the response\n\n    if (!serverParams.code) {\n      throw ClientAuthError.createNoAuthCodeInServerResponseError();\n    }\n\n    return __assign(__assign({}, serverParams), {\n      // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod\n      code: serverParams.code\n    });\n  };\n  /**\r\n   * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param authorityUri\r\n   */\n\n\n  AuthorizationCodeClient.prototype.getLogoutUri = function (logoutRequest) {\n    // Throw error if logoutRequest is null/undefined\n    if (!logoutRequest) {\n      throw ClientConfigurationError.createEmptyLogoutRequestError();\n    }\n\n    var queryString = this.createLogoutUrlQueryString(logoutRequest); // Construct logout URI.\n\n    return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\n  };\n  /**\r\n   * Executes POST request to token endpoint\r\n   * @param authority\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.executeTokenRequest = function (authority, request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var thumbprint, requestBody, queryParameters, ccsCredential, clientInfo, headers, endpoint;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            thumbprint = {\n              clientId: this.config.authOptions.clientId,\n              authority: authority.canonicalAuthority,\n              scopes: request.scopes,\n              claims: request.claims,\n              authenticationScheme: request.authenticationScheme,\n              resourceRequestMethod: request.resourceRequestMethod,\n              resourceRequestUri: request.resourceRequestUri,\n              shrClaims: request.shrClaims,\n              sshKid: request.sshKid\n            };\n            return [4\n            /*yield*/\n            , this.createTokenRequestBody(request)];\n\n          case 1:\n            requestBody = _a.sent();\n            queryParameters = this.createTokenQueryParameters(request);\n            ccsCredential = undefined;\n\n            if (request.clientInfo) {\n              try {\n                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCredential = {\n                  credential: \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,\n                  type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n              } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n              }\n            }\n\n            headers = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\n            endpoint = StringUtils.isEmpty(queryParameters) ? authority.tokenEndpoint : authority.tokenEndpoint + \"?\" + queryParameters;\n            return [2\n            /*return*/\n            , this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates query string for the /token request\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createTokenQueryParameters = function (request) {\n    var parameterBuilder = new RequestParameterBuilder();\n\n    if (request.tokenQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);\n    }\n\n    return parameterBuilder.createQueryString();\n  };\n  /**\r\n   * Generates a map for all the params to be sent to the service\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createTokenRequestBody = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var parameterBuilder, clientAssertion, popTokenGenerator, cnfString, correlationId, ccsCred, clientInfo, clientInfo;\n\n      var _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            parameterBuilder = new RequestParameterBuilder();\n            parameterBuilder.addClientId(this.config.authOptions.clientId);\n            /*\r\n             * For hybrid spa flow, there will be a code but no verifier\r\n             * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\r\n             */\n\n            if (!this.includeRedirectUri) {\n              // Just validate\n              RequestValidator.validateRedirectUri(request.redirectUri);\n            } else {\n              // Validate and include redirect uri\n              parameterBuilder.addRedirectUri(request.redirectUri);\n            } // Add scope array, parameter builder will add default scopes and dedupe\n\n\n            parameterBuilder.addScopes(request.scopes); // add code: user set, not validated\n\n            parameterBuilder.addAuthorizationCode(request.code); // Add library metadata\n\n            parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n            parameterBuilder.addThrottling();\n\n            if (this.serverTelemetryManager) {\n              parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n            } // add code_verifier if passed\n\n\n            if (request.codeVerifier) {\n              parameterBuilder.addCodeVerifier(request.codeVerifier);\n            }\n\n            if (this.config.clientCredentials.clientSecret) {\n              parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n            }\n\n            if (this.config.clientCredentials.clientAssertion) {\n              clientAssertion = this.config.clientCredentials.clientAssertion;\n              parameterBuilder.addClientAssertion(clientAssertion.assertion);\n              parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n            }\n\n            parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n            parameterBuilder.addClientInfo();\n            if (!(request.authenticationScheme === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 2];\n            popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\n            return [4\n            /*yield*/\n            , popTokenGenerator.generateCnf(request)];\n\n          case 1:\n            cnfString = _b.sent();\n            parameterBuilder.addPopToken(cnfString);\n            return [3\n            /*break*/\n            , 3];\n\n          case 2:\n            if (request.authenticationScheme === AuthenticationScheme.SSH) {\n              if (request.sshJwk) {\n                parameterBuilder.addSshJwk(request.sshJwk);\n              } else {\n                throw ClientConfigurationError.createMissingSshJwkError();\n              }\n            }\n\n            _b.label = 3;\n\n          case 3:\n            correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n            parameterBuilder.addCorrelationId(correlationId);\n\n            if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n              parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n            }\n\n            ccsCred = undefined;\n\n            if (request.clientInfo) {\n              try {\n                clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCred = {\n                  credential: \"\" + clientInfo.uid + Separators.CLIENT_INFO_SEPARATOR + clientInfo.utid,\n                  type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n              } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n              }\n            } else {\n              ccsCred = request.ccsCredential;\n            } // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n\n\n            if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n              switch (ccsCred.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                  try {\n                    clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\n                    parameterBuilder.addCcsOid(clientInfo);\n                  } catch (e) {\n                    this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n                  }\n\n                  break;\n\n                case CcsCredentialType.UPN:\n                  parameterBuilder.addCcsUpn(ccsCred.credential);\n                  break;\n              }\n            }\n\n            if (request.tokenBodyParameters) {\n              parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);\n            } // Add hybrid spa parameters if not already provided\n\n\n            if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {\n              parameterBuilder.addExtraQueryParameters((_a = {}, _a[AADServerParamKeys.RETURN_SPA_CODE] = \"1\", _a));\n            }\n\n            return [2\n            /*return*/\n            , parameterBuilder.createQueryString()];\n        }\n      });\n    });\n  };\n  /**\r\n   * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createAuthCodeUrlQueryString = function (request) {\n    var parameterBuilder = new RequestParameterBuilder();\n    parameterBuilder.addClientId(this.config.authOptions.clientId);\n\n    var requestScopes = __spreadArrays(request.scopes || [], request.extraScopesToConsent || []);\n\n    parameterBuilder.addScopes(requestScopes); // validate the redirectUri (to be a non null value)\n\n    parameterBuilder.addRedirectUri(request.redirectUri); // generate the correlationId if not set by the user and add\n\n    var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n    parameterBuilder.addCorrelationId(correlationId); // add response_mode. If not passed in it defaults to query.\n\n    parameterBuilder.addResponseMode(request.responseMode); // add response_type = code\n\n    parameterBuilder.addResponseTypeCode(); // add library info parameters\n\n    parameterBuilder.addLibraryInfo(this.config.libraryInfo); // add client_info=1\n\n    parameterBuilder.addClientInfo();\n\n    if (request.codeChallenge && request.codeChallengeMethod) {\n      parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\n    }\n\n    if (request.prompt) {\n      parameterBuilder.addPrompt(request.prompt);\n    }\n\n    if (request.domainHint) {\n      parameterBuilder.addDomainHint(request.domainHint);\n    } // Add sid or loginHint with preference for sid -> loginHint -> username of AccountInfo object\n\n\n    if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n      // AAD will throw if prompt=select_account is passed with an account hint\n      if (request.sid && request.prompt === PromptValue.NONE) {\n        // SessionID is only used in silent calls\n        this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\n        parameterBuilder.addSid(request.sid);\n      } else if (request.account) {\n        var accountSid = this.extractAccountSid(request.account); // If account and loginHint are provided, we will check account first for sid before adding loginHint\n\n        if (accountSid && request.prompt === PromptValue.NONE) {\n          // SessionId is only used in silent calls\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\n          parameterBuilder.addSid(accountSid);\n\n          try {\n            var clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n          }\n        } else if (request.loginHint) {\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\n          parameterBuilder.addLoginHint(request.loginHint);\n          parameterBuilder.addCcsUpn(request.loginHint);\n        } else if (request.account.username) {\n          // Fallback to account username if provided\n          this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\n          parameterBuilder.addLoginHint(request.account.username);\n\n          try {\n            var clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n            parameterBuilder.addCcsOid(clientInfo);\n          } catch (e) {\n            this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n          }\n        }\n      } else if (request.loginHint) {\n        this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\n        parameterBuilder.addLoginHint(request.loginHint);\n        parameterBuilder.addCcsUpn(request.loginHint);\n      }\n    } else {\n      this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\n    }\n\n    if (request.nonce) {\n      parameterBuilder.addNonce(request.nonce);\n    }\n\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n\n    if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n    }\n\n    if (request.extraQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n    }\n\n    return parameterBuilder.createQueryString();\n  };\n  /**\r\n   * This API validates the `EndSessionRequest` and creates a URL\r\n   * @param request\r\n   */\n\n\n  AuthorizationCodeClient.prototype.createLogoutUrlQueryString = function (request) {\n    var parameterBuilder = new RequestParameterBuilder();\n\n    if (request.postLogoutRedirectUri) {\n      parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\n    }\n\n    if (request.correlationId) {\n      parameterBuilder.addCorrelationId(request.correlationId);\n    }\n\n    if (request.idTokenHint) {\n      parameterBuilder.addIdTokenHint(request.idTokenHint);\n    }\n\n    if (request.state) {\n      parameterBuilder.addState(request.state);\n    }\n\n    if (request.logoutHint) {\n      parameterBuilder.addLogoutHint(request.logoutHint);\n    }\n\n    if (request.extraQueryParameters) {\n      parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n    }\n\n    return parameterBuilder.createQueryString();\n  };\n  /**\r\n   * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\r\n   * @param account\r\n   */\n\n\n  AuthorizationCodeClient.prototype.extractAccountSid = function (account) {\n    if (account.idTokenClaims) {\n      var tokenClaims = account.idTokenClaims;\n      return tokenClaims.sid || null;\n    }\n\n    return null;\n  };\n\n  return AuthorizationCodeClient;\n}(BaseClient);\n\nexport { AuthorizationCodeClient };","map":{"version":3,"mappings":"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","names":["__extends","configuration","_super","_this","AuthorizationCodeClient","request","queryString","createAuthCodeUrlQueryString","UrlString","appendQueryString","authority","authorizationEndpoint","authCodePayload","logger","info","StringUtils","isEmpty","code","ClientAuthError","createTokenRequestCannotBeMadeError","reqTimestamp","TimeUtils","nowSeconds","executeTokenRequest","response","_a","responseHandler","ResponseHandler","config","authOptions","clientId","cacheManager","cryptoUtils","serializableCache","persistencePlugin","validateTokenResponse","body","handleServerTokenResponse","hashFragment","cachedState","hashUrlString","serverParams","getDeserializedHash","getHash","validateServerAuthorizationCodeResponse","createNoAuthCodeInServerResponseError","logoutRequest","ClientConfigurationError","createEmptyLogoutRequestError","createLogoutUrlQueryString","endSessionEndpoint","thumbprint","canonicalAuthority","scopes","claims","authenticationScheme","resourceRequestMethod","resourceRequestUri","shrClaims","sshKid","createTokenRequestBody","requestBody","queryParameters","createTokenQueryParameters","ccsCredential","undefined","clientInfo","buildClientInfo","credential","uid","Separators","CLIENT_INFO_SEPARATOR","utid","type","CcsCredentialType","HOME_ACCOUNT_ID","e","verbose","headers","createTokenRequestHeaders","endpoint","tokenEndpoint","executePostToTokenEndpoint","parameterBuilder","RequestParameterBuilder","tokenQueryParameters","addExtraQueryParameters","createQueryString","addClientId","includeRedirectUri","RequestValidator","validateRedirectUri","redirectUri","addRedirectUri","addScopes","addAuthorizationCode","addLibraryInfo","libraryInfo","addThrottling","serverTelemetryManager","addServerTelemetry","codeVerifier","addCodeVerifier","clientCredentials","clientSecret","addClientSecret","clientAssertion","addClientAssertion","assertion","addClientAssertionType","assertionType","addGrantType","GrantType","AUTHORIZATION_CODE_GRANT","addClientInfo","AuthenticationScheme","POP","popTokenGenerator","PopTokenGenerator","generateCnf","cnfString","_b","addPopToken","SSH","sshJwk","addSshJwk","createMissingSshJwkError","correlationId","cryptoInterface","createNewGuid","addCorrelationId","isEmptyObj","clientCapabilities","length","addClaims","ccsCred","systemOptions","preventCorsPreflight","buildClientInfoFromHomeAccountId","addCcsOid","UPN","addCcsUpn","tokenBodyParameters","enableSpaAuthorizationCode","AADServerParamKeys","RETURN_SPA_CODE","requestScopes","extraScopesToConsent","addResponseMode","responseMode","addResponseTypeCode","codeChallenge","codeChallengeMethod","addCodeChallengeParams","prompt","addPrompt","domainHint","addDomainHint","PromptValue","SELECT_ACCOUNT","sid","NONE","addSid","account","accountSid","extractAccountSid","homeAccountId","loginHint","addLoginHint","username","nonce","addNonce","state","addState","extraQueryParameters","postLogoutRedirectUri","addPostLogoutRedirectUri","idTokenHint","addIdTokenHint","logoutHint","addLogoutHint","idTokenClaims","tokenClaims","BaseClient"],"sources":["C:\\Users\\empti\\OneDrive\\Desktop\\User_Interface\\user_interface_frontend\\node_modules\\@azure\\msal-common\\src\\client\\AuthorizationCodeClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BaseClient } from \"./BaseClient\";\nimport { CommonAuthorizationUrlRequest } from \"../request/CommonAuthorizationUrlRequest\";\nimport { CommonAuthorizationCodeRequest } from \"../request/CommonAuthorizationCodeRequest\";\nimport { Authority } from \"../authority/Authority\";\nimport { RequestParameterBuilder } from \"../request/RequestParameterBuilder\";\nimport { GrantType, AuthenticationScheme, PromptValue, Separators, AADServerParamKeys } from \"../utils/Constants\";\nimport { ClientConfiguration } from \"../config/ClientConfiguration\";\nimport { ServerAuthorizationTokenResponse } from \"../response/ServerAuthorizationTokenResponse\";\nimport { NetworkResponse } from \"../network/NetworkManager\";\nimport { ResponseHandler } from \"../response/ResponseHandler\";\nimport { AuthenticationResult } from \"../response/AuthenticationResult\";\nimport { StringUtils } from \"../utils/StringUtils\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { UrlString } from \"../url/UrlString\";\nimport { ServerAuthorizationCodeResponse } from \"../response/ServerAuthorizationCodeResponse\";\nimport { CommonEndSessionRequest } from \"../request/CommonEndSessionRequest\";\nimport { PopTokenGenerator } from \"../crypto/PopTokenGenerator\";\nimport { RequestThumbprint } from \"../network/RequestThumbprint\";\nimport { AuthorizationCodePayload } from \"../response/AuthorizationCodePayload\";\nimport { TimeUtils } from \"../utils/TimeUtils\";\nimport { TokenClaims } from \"../account/TokenClaims\";\nimport { AccountInfo } from \"../account/AccountInfo\";\nimport { buildClientInfoFromHomeAccountId, buildClientInfo } from \"../account/ClientInfo\";\nimport { CcsCredentialType, CcsCredential } from \"../account/CcsCredential\";\nimport { ClientConfigurationError } from \"../error/ClientConfigurationError\";\nimport { RequestValidator } from \"../request/RequestValidator\";\n\n/**\n * Oauth2.0 Authorization Code client\n */\nexport class AuthorizationCodeClient extends BaseClient {\n    // Flag to indicate if client is for hybrid spa auth code redemption\n    protected includeRedirectUri: boolean = true;\n\n    constructor(configuration: ClientConfiguration) {\n        super(configuration);\n    }\n\n    /**\n     * Creates the URL of the authorization request letting the user input credentials and consent to the\n     * application. The URL target the /authorize endpoint of the authority configured in the\n     * application object.\n     *\n     * Once the user inputs their credentials and consents, the authority will send a response to the redirect URI\n     * sent in the request and should contain an authorization code, which can then be used to acquire tokens via\n     * acquireToken(AuthorizationCodeRequest)\n     * @param request\n     */\n    async getAuthCodeUrl(request: CommonAuthorizationUrlRequest): Promise<string> {\n        const queryString = this.createAuthCodeUrlQueryString(request);\n\n        return UrlString.appendQueryString(this.authority.authorizationEndpoint, queryString);\n    }\n\n    /**\n     * API to acquire a token in exchange of 'authorization_code` acquired by the user in the first leg of the\n     * authorization_code_grant\n     * @param request\n     */\n    async acquireToken(request: CommonAuthorizationCodeRequest, authCodePayload?: AuthorizationCodePayload): Promise<AuthenticationResult> {\n        this.logger.info(\"in acquireToken call\");\n        if (!request || StringUtils.isEmpty(request.code)) {\n            throw ClientAuthError.createTokenRequestCannotBeMadeError();\n        }\n\n        const reqTimestamp = TimeUtils.nowSeconds();\n        const response = await this.executeTokenRequest(this.authority, request);\n\n        const responseHandler = new ResponseHandler(\n            this.config.authOptions.clientId,\n            this.cacheManager,\n            this.cryptoUtils,\n            this.logger,\n            this.config.serializableCache,\n            this.config.persistencePlugin\n        );\n\n        // Validate response. This function throws a server error if an error is returned by the server.\n        responseHandler.validateTokenResponse(response.body);\n        return await responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, authCodePayload);\n    }\n\n    /**\n     * Handles the hash fragment response from public client code request. Returns a code response used by\n     * the client to exchange for a token in acquireToken.\n     * @param hashFragment\n     */\n    handleFragmentResponse(hashFragment: string, cachedState: string): AuthorizationCodePayload {\n        // Handle responses.\n        const responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, null, null);\n\n        // Deserialize hash fragment response parameters.\n        const hashUrlString = new UrlString(hashFragment);\n        // Deserialize hash fragment response parameters.\n        const serverParams: ServerAuthorizationCodeResponse = UrlString.getDeserializedHash(hashUrlString.getHash());\n\n        // Get code response\n        responseHandler.validateServerAuthorizationCodeResponse(serverParams, cachedState, this.cryptoUtils);\n\n        // throw when there is no auth code in the response\n        if (!serverParams.code) {\n            throw ClientAuthError.createNoAuthCodeInServerResponseError();\n        }\n        return {\n            ...serverParams,\n            // Code param is optional in ServerAuthorizationCodeResponse but required in AuthorizationCodePaylod\n            code: serverParams.code\n        };\n    }\n\n    /**\n     * Used to log out the current user, and redirect the user to the postLogoutRedirectUri.\n     * Default behaviour is to redirect the user to `window.location.href`.\n     * @param authorityUri\n     */\n    getLogoutUri(logoutRequest: CommonEndSessionRequest): string {\n        // Throw error if logoutRequest is null/undefined\n        if (!logoutRequest) {\n            throw ClientConfigurationError.createEmptyLogoutRequestError();\n        }\n        const queryString = this.createLogoutUrlQueryString(logoutRequest);\n\n        // Construct logout URI.\n        return UrlString.appendQueryString(this.authority.endSessionEndpoint, queryString);\n    }\n\n    /**\n     * Executes POST request to token endpoint\n     * @param authority\n     * @param request\n     */\n    private async executeTokenRequest(authority: Authority, request: CommonAuthorizationCodeRequest): Promise<NetworkResponse<ServerAuthorizationTokenResponse>> {\n        const thumbprint: RequestThumbprint = {\n            clientId: this.config.authOptions.clientId,\n            authority: authority.canonicalAuthority,\n            scopes: request.scopes,\n            claims: request.claims,\n            authenticationScheme: request.authenticationScheme,\n            resourceRequestMethod: request.resourceRequestMethod,\n            resourceRequestUri: request.resourceRequestUri,\n            shrClaims: request.shrClaims,\n            sshKid: request.sshKid\n        };\n\n        const requestBody = await this.createTokenRequestBody(request);\n        const queryParameters = this.createTokenQueryParameters(request);\n        let ccsCredential: CcsCredential | undefined = undefined;\n        if (request.clientInfo) {\n            try {\n                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCredential = {\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n                    type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n            } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n            }\n        }\n        const headers: Record<string, string> = this.createTokenRequestHeaders(ccsCredential || request.ccsCredential);\n        const endpoint = StringUtils.isEmpty(queryParameters) ? authority.tokenEndpoint : `${authority.tokenEndpoint}?${queryParameters}`;\n\n        return this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint);\n    }\n\n    /**\n     * Creates query string for the /token request\n     * @param request \n     */\n    private createTokenQueryParameters(request: CommonAuthorizationCodeRequest): string {\n        const parameterBuilder = new RequestParameterBuilder();\n\n        if (request.tokenQueryParameters) {\n            parameterBuilder.addExtraQueryParameters(request.tokenQueryParameters);\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * Generates a map for all the params to be sent to the service\n     * @param request\n     */\n    private async createTokenRequestBody(request: CommonAuthorizationCodeRequest): Promise<string> {\n        const parameterBuilder = new RequestParameterBuilder();\n\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\n\n        /*\n         * For hybrid spa flow, there will be a code but no verifier\n         * In this scenario, don't include redirect uri as auth code will not be bound to redirect URI\n         */\n        if (!this.includeRedirectUri) {\n            // Just validate\n            RequestValidator.validateRedirectUri(request.redirectUri);\n        } else {\n            // Validate and include redirect uri\n            parameterBuilder.addRedirectUri(request.redirectUri);\n        }\n\n        // Add scope array, parameter builder will add default scopes and dedupe\n        parameterBuilder.addScopes(request.scopes);\n\n        // add code: user set, not validated\n        parameterBuilder.addAuthorizationCode(request.code);\n\n        // Add library metadata\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n\n        parameterBuilder.addThrottling();\n        \n        if (this.serverTelemetryManager) {\n            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n        }\n\n        // add code_verifier if passed\n        if (request.codeVerifier) {\n            parameterBuilder.addCodeVerifier(request.codeVerifier);\n        }\n\n        if (this.config.clientCredentials.clientSecret) {\n            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n        }\n\n        if (this.config.clientCredentials.clientAssertion) {\n            const clientAssertion = this.config.clientCredentials.clientAssertion;\n            parameterBuilder.addClientAssertion(clientAssertion.assertion);\n            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n        }\n\n        parameterBuilder.addGrantType(GrantType.AUTHORIZATION_CODE_GRANT);\n        parameterBuilder.addClientInfo();\n\n        if (request.authenticationScheme === AuthenticationScheme.POP) {\n            const popTokenGenerator = new PopTokenGenerator(this.cryptoUtils);\n            const cnfString = await popTokenGenerator.generateCnf(request);\n            parameterBuilder.addPopToken(cnfString);\n        } else if (request.authenticationScheme === AuthenticationScheme.SSH) {\n            if(request.sshJwk) {\n                parameterBuilder.addSshJwk(request.sshJwk);\n            } else {\n                throw ClientConfigurationError.createMissingSshJwkError();\n            }\n        }\n\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n        parameterBuilder.addCorrelationId(correlationId);\n\n        if (!StringUtils.isEmptyObj(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n        }\n        \n        let ccsCred: CcsCredential | undefined = undefined;\n        if (request.clientInfo) {\n            try {\n                const clientInfo = buildClientInfo(request.clientInfo, this.cryptoUtils);\n                ccsCred = {\n                    credential: `${clientInfo.uid}${Separators.CLIENT_INFO_SEPARATOR}${clientInfo.utid}`,\n                    type: CcsCredentialType.HOME_ACCOUNT_ID\n                };\n            } catch (e) {\n                this.logger.verbose(\"Could not parse client info for CCS Header: \" + e);\n            }\n        } else {\n            ccsCred = request.ccsCredential;\n        }\n\n        // Adds these as parameters in the request instead of headers to prevent CORS preflight request\n        if (this.config.systemOptions.preventCorsPreflight && ccsCred) {\n            switch (ccsCred.type) {\n                case CcsCredentialType.HOME_ACCOUNT_ID:\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(ccsCred.credential);\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n                    }\n                    break;\n                case CcsCredentialType.UPN:\n                    parameterBuilder.addCcsUpn(ccsCred.credential);\n                    break;\n            }\n        }\n\n        if (request.tokenBodyParameters) {\n            parameterBuilder.addExtraQueryParameters(request.tokenBodyParameters);\n        }\n\n        // Add hybrid spa parameters if not already provided\n        if (request.enableSpaAuthorizationCode && (!request.tokenBodyParameters || !request.tokenBodyParameters[AADServerParamKeys.RETURN_SPA_CODE])) {\n            parameterBuilder.addExtraQueryParameters({\n                [AADServerParamKeys.RETURN_SPA_CODE]: \"1\"\n            });\n        }\n        \n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * This API validates the `AuthorizationCodeUrlRequest` and creates a URL\n     * @param request\n     */\n    private createAuthCodeUrlQueryString(request: CommonAuthorizationUrlRequest): string {\n        const parameterBuilder = new RequestParameterBuilder();\n\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\n\n        const requestScopes = [...request.scopes || [], ...request.extraScopesToConsent || []];\n        parameterBuilder.addScopes(requestScopes);\n\n        // validate the redirectUri (to be a non null value)\n        parameterBuilder.addRedirectUri(request.redirectUri);\n\n        // generate the correlationId if not set by the user and add\n        const correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n        parameterBuilder.addCorrelationId(correlationId);\n\n        // add response_mode. If not passed in it defaults to query.\n        parameterBuilder.addResponseMode(request.responseMode);\n\n        // add response_type = code\n        parameterBuilder.addResponseTypeCode();\n\n        // add library info parameters\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n\n        // add client_info=1\n        parameterBuilder.addClientInfo();\n\n        if (request.codeChallenge && request.codeChallengeMethod) {\n            parameterBuilder.addCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);\n        }\n\n        if (request.prompt) {\n            parameterBuilder.addPrompt(request.prompt);\n        }\n\n        if (request.domainHint) {\n            parameterBuilder.addDomainHint(request.domainHint);\n        }\n\n        // Add sid or loginHint with preference for sid -> loginHint -> username of AccountInfo object\n        if (request.prompt !== PromptValue.SELECT_ACCOUNT) {\n            // AAD will throw if prompt=select_account is passed with an account hint\n            if (request.sid && request.prompt === PromptValue.NONE) {\n                // SessionID is only used in silent calls\n                this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from request\");\n                parameterBuilder.addSid(request.sid);\n            } else if (request.account) {\n                const accountSid = this.extractAccountSid(request.account);\n                // If account and loginHint are provided, we will check account first for sid before adding loginHint\n                if (accountSid && request.prompt === PromptValue.NONE) {\n                    // SessionId is only used in silent calls\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is none, adding sid from account\");\n                    parameterBuilder.addSid(accountSid);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\"Could not parse home account ID for CCS Header: \" + e);\n                    }\n                } else if (request.loginHint) {\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from request\");\n                    parameterBuilder.addLoginHint(request.loginHint);\n                    parameterBuilder.addCcsUpn(request.loginHint);\n                } else if (request.account.username) {\n                    // Fallback to account username if provided\n                    this.logger.verbose(\"createAuthCodeUrlQueryString: Adding login_hint from account\");\n                    parameterBuilder.addLoginHint(request.account.username);\n                    try {\n                        const clientInfo = buildClientInfoFromHomeAccountId(request.account.homeAccountId);\n                        parameterBuilder.addCcsOid(clientInfo);\n                    } catch (e) {\n                        this.logger.verbose(\"Could not parse home account ID for CCS Header: \" +  e);\n                    }\n                }\n            } else if (request.loginHint) {\n                this.logger.verbose(\"createAuthCodeUrlQueryString: No account, adding login_hint from request\");\n                parameterBuilder.addLoginHint(request.loginHint);\n                parameterBuilder.addCcsUpn(request.loginHint);\n            }\n        } else {\n            this.logger.verbose(\"createAuthCodeUrlQueryString: Prompt is select_account, ignoring account hints\");\n        }\n\n        if (request.nonce) {\n            parameterBuilder.addNonce(request.nonce);\n        }\n\n        if (request.state) {\n            parameterBuilder.addState(request.state);\n        }\n\n        if (!StringUtils.isEmpty(request.claims) || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n        }\n\n        if (request.extraQueryParameters) {\n            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * This API validates the `EndSessionRequest` and creates a URL\n     * @param request\n     */\n    private createLogoutUrlQueryString(request: CommonEndSessionRequest): string {\n        const parameterBuilder = new RequestParameterBuilder();\n\n        if (request.postLogoutRedirectUri) {\n            parameterBuilder.addPostLogoutRedirectUri(request.postLogoutRedirectUri);\n        }\n\n        if (request.correlationId) {\n            parameterBuilder.addCorrelationId(request.correlationId);\n        }\n\n        if (request.idTokenHint) {\n            parameterBuilder.addIdTokenHint(request.idTokenHint);\n        }\n        \n        if(request.state) {\n            parameterBuilder.addState(request.state);\n        }\n\n        if (request.logoutHint) {\n            parameterBuilder.addLogoutHint(request.logoutHint);\n        }\n\n        if (request.extraQueryParameters) {\n            parameterBuilder.addExtraQueryParameters(request.extraQueryParameters);\n        }\n\n        return parameterBuilder.createQueryString();\n    }\n\n    /**\n     * Helper to get sid from account. Returns null if idTokenClaims are not present or sid is not present.\n     * @param account \n     */\n    private extractAccountSid(account: AccountInfo): string | null {\n        if (account.idTokenClaims) {\n            const tokenClaims = account.idTokenClaims as TokenClaims;\n            return tokenClaims.sid || null;\n        }\n        return null;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}