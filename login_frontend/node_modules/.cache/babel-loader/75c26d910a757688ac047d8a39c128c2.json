{"ast":null,"code":"/*! @azure/msal-browser v2.22.0 2022-02-08 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __assign } from '../_virtual/_tslib.js';\nimport { UrlString, Constants, AuthorizationCodeClient, Authority, AuthorityFactory, ResponseMode, StringUtils, ProtocolUtils } from '@azure/msal-common';\nimport { BaseInteractionClient } from './BaseInteractionClient.js';\nimport { BrowserConstants } from '../utils/BrowserConstants.js';\nimport { version } from '../packageMetadata.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.js';\nimport { BrowserUtils } from '../utils/BrowserUtils.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Defines the class structure and helper functions used by the \"standard\", non-brokered auth flows (popup, redirect, silent (RT), silent (iframe))\r\n */\n\nvar StandardInteractionClient =\n/** @class */\nfunction (_super) {\n  __extends(StandardInteractionClient, _super);\n\n  function StandardInteractionClient(config, storageImpl, browserCrypto, logger, eventHandler, navigationClient, correlationId) {\n    var _this = _super.call(this, config, storageImpl, browserCrypto, logger, eventHandler, correlationId) || this;\n\n    _this.navigationClient = navigationClient;\n    return _this;\n  }\n  /**\r\n   * Generates an auth code request tied to the url request.\r\n   * @param request\r\n   */\n\n\n  StandardInteractionClient.prototype.initializeAuthorizationCodeRequest = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var generatedPkceParams, authCodeRequest;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"initializeAuthorizationRequest called\", request.correlationId);\n            return [4\n            /*yield*/\n            , this.browserCrypto.generatePkceCodes()];\n\n          case 1:\n            generatedPkceParams = _a.sent();\n            authCodeRequest = __assign(__assign({}, request), {\n              redirectUri: request.redirectUri,\n              code: \"\",\n              codeVerifier: generatedPkceParams.verifier\n            });\n            request.codeChallenge = generatedPkceParams.challenge;\n            request.codeChallengeMethod = Constants.S256_CODE_CHALLENGE_METHOD;\n            return [2\n            /*return*/\n            , authCodeRequest];\n        }\n      });\n    });\n  };\n  /**\r\n   * Initializer for the logout request.\r\n   * @param logoutRequest\r\n   */\n\n\n  StandardInteractionClient.prototype.initializeLogoutRequest = function (logoutRequest) {\n    this.logger.verbose(\"initializeLogoutRequest called\", logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.correlationId);\n\n    var validLogoutRequest = __assign({\n      correlationId: this.browserCrypto.createNewGuid()\n    }, logoutRequest);\n    /**\r\n     * Set logout_hint to be login_hint from ID Token Claims if present\r\n     * and logoutHint attribute wasn't manually set in logout request\r\n     */\n\n\n    if (logoutRequest) {\n      // If logoutHint isn't set and an account was passed in, try to extract logoutHint from ID Token Claims\n      if (!logoutRequest.logoutHint) {\n        if (logoutRequest.account) {\n          var logoutHint = this.getLogoutHintFromIdTokenClaims(logoutRequest.account);\n\n          if (logoutHint) {\n            this.logger.verbose(\"Setting logoutHint to login_hint ID Token Claim value for the account provided\");\n            validLogoutRequest.logoutHint = logoutHint;\n          }\n        } else {\n          this.logger.verbose(\"logoutHint was not set and account was not passed into logout request, logoutHint will not be set\");\n        }\n      } else {\n        this.logger.verbose(\"logoutHint has already been set in logoutRequest\");\n      }\n    } else {\n      this.logger.verbose(\"logoutHint will not be set since no logout request was configured\");\n    }\n    /*\r\n     * Only set redirect uri if logout request isn't provided or the set uri isn't null.\r\n     * Otherwise, use passed uri, config, or current page.\r\n     */\n\n\n    if (!logoutRequest || logoutRequest.postLogoutRedirectUri !== null) {\n      if (logoutRequest && logoutRequest.postLogoutRedirectUri) {\n        this.logger.verbose(\"Setting postLogoutRedirectUri to uri set on logout request\", validLogoutRequest.correlationId);\n        validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(logoutRequest.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\n      } else if (this.config.auth.postLogoutRedirectUri === null) {\n        this.logger.verbose(\"postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect\", validLogoutRequest.correlationId);\n      } else if (this.config.auth.postLogoutRedirectUri) {\n        this.logger.verbose(\"Setting postLogoutRedirectUri to configured uri\", validLogoutRequest.correlationId);\n        validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\n      } else {\n        this.logger.verbose(\"Setting postLogoutRedirectUri to current page\", validLogoutRequest.correlationId);\n        validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(BrowserUtils.getCurrentUri(), BrowserUtils.getCurrentUri());\n      }\n    } else {\n      this.logger.verbose(\"postLogoutRedirectUri passed as null, not setting post logout redirect uri\", validLogoutRequest.correlationId);\n    }\n\n    return validLogoutRequest;\n  };\n  /**\r\n   * Parses login_hint ID Token Claim out of AccountInfo object to be used as\r\n   * logout_hint in end session request.\r\n   * @param account\r\n   */\n\n\n  StandardInteractionClient.prototype.getLogoutHintFromIdTokenClaims = function (account) {\n    var idTokenClaims = account.idTokenClaims;\n\n    if (idTokenClaims) {\n      if (idTokenClaims.login_hint) {\n        return idTokenClaims.login_hint;\n      } else {\n        this.logger.verbose(\"The ID Token Claims tied to the provided account do not contain a login_hint claim, logoutHint will not be added to logout request\");\n      }\n    } else {\n      this.logger.verbose(\"The provided account does not contain ID Token Claims, logoutHint will not be added to logout request\");\n    }\n\n    return null;\n  };\n  /**\r\n   * Creates an Authorization Code Client with the given authority, or the default authority.\r\n   * @param serverTelemetryManager\r\n   * @param authorityUrl\r\n   */\n\n\n  StandardInteractionClient.prototype.createAuthCodeClient = function (serverTelemetryManager, authorityUrl, requestAzureCloudOptions) {\n    return __awaiter(this, void 0, void 0, function () {\n      var clientConfig;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getClientConfiguration(serverTelemetryManager, authorityUrl, requestAzureCloudOptions)];\n\n          case 1:\n            clientConfig = _a.sent();\n            return [2\n            /*return*/\n            , new AuthorizationCodeClient(clientConfig)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates a Client Configuration object with the given request authority, or the default authority.\r\n   * @param serverTelemetryManager\r\n   * @param requestAuthority\r\n   * @param requestCorrelationId\r\n   */\n\n\n  StandardInteractionClient.prototype.getClientConfiguration = function (serverTelemetryManager, requestAuthority, requestAzureCloudOptions) {\n    return __awaiter(this, void 0, void 0, function () {\n      var discoveredAuthority;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"getClientConfiguration called\");\n            return [4\n            /*yield*/\n            , this.getDiscoveredAuthority(requestAuthority, requestAzureCloudOptions)];\n\n          case 1:\n            discoveredAuthority = _a.sent();\n            return [2\n            /*return*/\n            , {\n              authOptions: {\n                clientId: this.config.auth.clientId,\n                authority: discoveredAuthority,\n                clientCapabilities: this.config.auth.clientCapabilities\n              },\n              systemOptions: {\n                tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds,\n                preventCorsPreflight: true\n              },\n              loggerOptions: {\n                loggerCallback: this.config.system.loggerOptions.loggerCallback,\n                piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,\n                logLevel: this.config.system.loggerOptions.logLevel,\n                correlationId: this.correlationId\n              },\n              cryptoInterface: this.browserCrypto,\n              networkInterface: this.networkClient,\n              storageInterface: this.browserStorage,\n              serverTelemetryManager: serverTelemetryManager,\n              libraryInfo: {\n                sku: BrowserConstants.MSAL_SKU,\n                version: version,\n                cpu: \"\",\n                os: \"\"\n              }\n            }];\n        }\n      });\n    });\n  };\n  /**\r\n   * @param hash\r\n   * @param interactionType\r\n   */\n\n\n  StandardInteractionClient.prototype.validateAndExtractStateFromHash = function (hash, interactionType, requestCorrelationId) {\n    this.logger.verbose(\"validateAndExtractStateFromHash called\", requestCorrelationId); // Deserialize hash fragment response parameters.\n\n    var serverParams = UrlString.getDeserializedHash(hash);\n\n    if (!serverParams.state) {\n      throw BrowserAuthError.createHashDoesNotContainStateError();\n    }\n\n    var platformStateObj = BrowserProtocolUtils.extractBrowserRequestState(this.browserCrypto, serverParams.state);\n\n    if (!platformStateObj) {\n      throw BrowserAuthError.createUnableToParseStateError();\n    }\n\n    if (platformStateObj.interactionType !== interactionType) {\n      throw BrowserAuthError.createStateInteractionTypeMismatchError();\n    }\n\n    this.logger.verbose(\"Returning state from hash\", requestCorrelationId);\n    return serverParams.state;\n  };\n  /**\r\n   * Used to get a discovered version of the default authority.\r\n   * @param requestAuthority\r\n   * @param requestCorrelationId\r\n   */\n\n\n  StandardInteractionClient.prototype.getDiscoveredAuthority = function (requestAuthority, requestAzureCloudOptions) {\n    return __awaiter(this, void 0, void 0, function () {\n      var authorityOptions, userAuthority, builtAuthority;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"getDiscoveredAuthority called\");\n            authorityOptions = {\n              protocolMode: this.config.auth.protocolMode,\n              knownAuthorities: this.config.auth.knownAuthorities,\n              cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n              authorityMetadata: this.config.auth.authorityMetadata\n            };\n            userAuthority = requestAuthority ? requestAuthority : this.config.auth.authority;\n            builtAuthority = Authority.generateAuthority(userAuthority, requestAzureCloudOptions || this.config.auth.azureCloudOptions);\n            this.logger.verbose(\"Creating discovered authority with configured authority\");\n            return [4\n            /*yield*/\n            , AuthorityFactory.createDiscoveredInstance(builtAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Helper to initialize required request parameters for interactive APIs and ssoSilent()\r\n   * @param request\r\n   * @param interactionType\r\n   */\n\n\n  StandardInteractionClient.prototype.initializeAuthorizationRequest = function (request, interactionType) {\n    return __awaiter(this, void 0, void 0, function () {\n      var redirectUri, browserState, state, validatedRequest, _a, account, legacyLoginHint;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.logger.verbose(\"initializeAuthorizationRequest called\");\n            redirectUri = this.getRedirectUri(request.redirectUri);\n            browserState = {\n              interactionType: interactionType\n            };\n            state = ProtocolUtils.setRequestState(this.browserCrypto, request && request.state || Constants.EMPTY_STRING, browserState);\n            _a = [{}];\n            return [4\n            /*yield*/\n            , this.initializeBaseRequest(request)];\n\n          case 1:\n            validatedRequest = __assign.apply(void 0, [__assign.apply(void 0, _a.concat([_b.sent()])), {\n              redirectUri: redirectUri,\n              state: state,\n              nonce: request.nonce || this.browserCrypto.createNewGuid(),\n              responseMode: ResponseMode.FRAGMENT\n            }]);\n            account = request.account || this.browserStorage.getActiveAccount();\n\n            if (account) {\n              this.logger.verbose(\"Setting validated request account\");\n              this.logger.verbosePii(\"Setting validated request account: \" + account);\n              validatedRequest.account = account;\n            } // Check for ADAL/MSAL v1 SSO\n\n\n            if (StringUtils.isEmpty(validatedRequest.loginHint) && !account) {\n              legacyLoginHint = this.browserStorage.getLegacyLoginHint();\n\n              if (legacyLoginHint) {\n                validatedRequest.loginHint = legacyLoginHint;\n              }\n            }\n\n            return [2\n            /*return*/\n            , validatedRequest];\n        }\n      });\n    });\n  };\n\n  return StandardInteractionClient;\n}(BaseInteractionClient);\n\nexport { StandardInteractionClient };","map":{"version":3,"mappings":";;;;;;;;;;;AAAA;;;;;AAsBA;;;;;;;AAGwDA;;AAGpD,qCAAYC,MAAZ,EAA0CC,WAA1C,EAA4EC,aAA5E,EAAoGC,MAApG,EAAoHC,YAApH,EAAgJC,gBAAhJ,EAAqLC,aAArL,EAA2M;AAA3M,gBACIC,kBAAMP,MAAN,EAAcC,WAAd,EAA2BC,aAA3B,EAA0CC,MAA1C,EAAkDC,YAAlD,EAAgEE,aAAhE,KAA8E,IADlF;;AAEIE,SAAI,CAACH,gBAAL,GAAwBA,gBAAxB;;AACH;;;;;;;AAMeI,2EAAhB,UAAmDC,OAAnD,EAAmF;;;;;;AAC/E,iBAAKP,MAAL,CAAYQ,OAAZ,CAAoB,uCAApB,EAA6DD,OAAO,CAACJ,aAArE;AAC4B;AAAA;AAAA,cAAM,KAAKJ,aAAL,CAAmBU,iBAAnB,EAAN;;;AAAtBC,+BAAmB,GAAGC,SAAtB;AAEAC,2BAAe,yBACdL,OADc,GACP;AACVM,yBAAW,EAAEN,OAAO,CAACM,WADX;AAEVC,kBAAI,EAAE,EAFI;AAGVC,0BAAY,EAAEL,mBAAmB,CAACM;AAHxB,aADO,CAAf;AAONT,mBAAO,CAACU,aAAR,GAAwBP,mBAAmB,CAACQ,SAA5C;AACAX,mBAAO,CAACY,mBAAR,GAA8BC,SAAS,CAACC,0BAAxC;AAEA;AAAA;AAAA,cAAOT,eAAP;;;;AACH,GAfe;;;;;;;AAqBNN,gEAAV,UAAkCgB,aAAlC,EAAmE;AAC/D,SAAKtB,MAAL,CAAYQ,OAAZ,CAAoB,gCAApB,EAAsDc,aAAa,SAAb,iBAAa,WAAb,GAAa,MAAb,gBAAa,CAAEnB,aAArE;;AAEA,QAAMoB,kBAAkB;AACpBpB,mBAAa,EAAE,KAAKJ,aAAL,CAAmByB,aAAnB;AADK,OAEjBF,aAFiB,CAAxB;;;;;;;AASA,QAAIA,aAAJ,EAAmB;;AAEf,UAAI,CAACA,aAAa,CAACG,UAAnB,EAA+B;AAC3B,YAAGH,aAAa,CAACI,OAAjB,EAA0B;AACtB,cAAMD,UAAU,GAAG,KAAKE,8BAAL,CAAoCL,aAAa,CAACI,OAAlD,CAAnB;;AACA,cAAID,UAAJ,EAAgB;AACZ,iBAAKzB,MAAL,CAAYQ,OAAZ,CAAoB,gFAApB;AACAe,8BAAkB,CAACE,UAAnB,GAAgCA,UAAhC;AACH;AACJ,SAND,MAMO;AACH,eAAKzB,MAAL,CAAYQ,OAAZ,CAAoB,mGAApB;AACH;AACJ,OAVD,MAUO;AACH,aAAKR,MAAL,CAAYQ,OAAZ,CAAoB,kDAApB;AACH;AACJ,KAfD,MAeO;AACH,WAAKR,MAAL,CAAYQ,OAAZ,CAAoB,mEAApB;AACH;;;;;;;AAMD,QAAI,CAACc,aAAD,IAAkBA,aAAa,CAACM,qBAAd,KAAwC,IAA9D,EAAoE;AAChE,UAAIN,aAAa,IAAIA,aAAa,CAACM,qBAAnC,EAA0D;AACtD,aAAK5B,MAAL,CAAYQ,OAAZ,CAAoB,4DAApB,EAAkFe,kBAAkB,CAACpB,aAArG;AACAoB,0BAAkB,CAACK,qBAAnB,GAA2CC,SAAS,CAACC,cAAV,CAAyBR,aAAa,CAACM,qBAAvC,EAA8DG,YAAY,CAACC,aAAb,EAA9D,CAA3C;AACH,OAHD,MAGO,IAAI,KAAKnC,MAAL,CAAYoC,IAAZ,CAAiBL,qBAAjB,KAA2C,IAA/C,EAAqD;AACxD,aAAK5B,MAAL,CAAYQ,OAAZ,CAAoB,sGAApB,EAA4He,kBAAkB,CAACpB,aAA/I;AACH,OAFM,MAEA,IAAI,KAAKN,MAAL,CAAYoC,IAAZ,CAAiBL,qBAArB,EAA4C;AAC/C,aAAK5B,MAAL,CAAYQ,OAAZ,CAAoB,iDAApB,EAAuEe,kBAAkB,CAACpB,aAA1F;AACAoB,0BAAkB,CAACK,qBAAnB,GAA2CC,SAAS,CAACC,cAAV,CAAyB,KAAKjC,MAAL,CAAYoC,IAAZ,CAAiBL,qBAA1C,EAAiEG,YAAY,CAACC,aAAb,EAAjE,CAA3C;AACH,OAHM,MAGA;AACH,aAAKhC,MAAL,CAAYQ,OAAZ,CAAoB,+CAApB,EAAqEe,kBAAkB,CAACpB,aAAxF;AACAoB,0BAAkB,CAACK,qBAAnB,GAA2CC,SAAS,CAACC,cAAV,CAAyBC,YAAY,CAACC,aAAb,EAAzB,EAAuDD,YAAY,CAACC,aAAb,EAAvD,CAA3C;AACH;AACJ,KAbD,MAaO;AACH,WAAKhC,MAAL,CAAYQ,OAAZ,CAAoB,4EAApB,EAAkGe,kBAAkB,CAACpB,aAArH;AACH;;AAED,WAAOoB,kBAAP;AACH,GArDS;;;;;;;;AA4DAjB,uEAAV,UAAyCoB,OAAzC,EAA6D;AACzD,QAAMQ,aAAa,GAA8BR,OAAO,CAACQ,aAAzD;;AACA,QAAIA,aAAJ,EAAmB;AACf,UAAIA,aAAa,CAACC,UAAlB,EAA8B;AAC1B,eAAOD,aAAa,CAACC,UAArB;AACH,OAFD,MAEO;AACH,aAAKnC,MAAL,CAAYQ,OAAZ,CAAoB,oIAApB;AACH;AACJ,KAND,MAMO;AACH,WAAKR,MAAL,CAAYQ,OAAZ,CAAoB,uGAApB;AACH;;AAED,WAAO,IAAP;AACH,GAbS;;;;;;;;AAoBMF,6DAAhB,UAAqC8B,sBAArC,EAAqFC,YAArF,EAA4GC,wBAA5G,EAAwJ;;;;;;AAE/H;AAAA;AAAA,cAAM,KAAKC,sBAAL,CAA4BH,sBAA5B,EAAoDC,YAApD,EAAkEC,wBAAlE,CAAN;;;AAAfE,wBAAY,GAAG7B,SAAf;AACN;AAAA;AAAA,cAAO,IAAI8B,uBAAJ,CAA4BD,YAA5B,CAAP;;;;AACH,GAJe;;;;;;;;;AAYAlC,+DAAhB,UAAuC8B,sBAAvC,EAAuFM,gBAAvF,EAAkHJ,wBAAlH,EAA8J;;;;;;AAC1J,iBAAKtC,MAAL,CAAYQ,OAAZ,CAAoB,+BAApB;AAC4B;AAAA;AAAA,cAAM,KAAKmC,sBAAL,CAA4BD,gBAA5B,EAA8CJ,wBAA9C,CAAN;;;AAAtBM,+BAAmB,GAAGjC,SAAtB;AAEN;AAAA;AAAA,cAAO;AACHkC,yBAAW,EAAE;AACTC,wBAAQ,EAAE,KAAKjD,MAAL,CAAYoC,IAAZ,CAAiBa,QADlB;AAETC,yBAAS,EAAEH,mBAFF;AAGTI,kCAAkB,EAAE,KAAKnD,MAAL,CAAYoC,IAAZ,CAAiBe;AAH5B,eADV;AAMHC,2BAAa,EAAE;AACXC,yCAAyB,EAAE,KAAKrD,MAAL,CAAYsD,MAAZ,CAAmBD,yBADnC;AAEXE,oCAAoB,EAAE;AAFX,eANZ;AAUHC,2BAAa,EAAE;AACXC,8BAAc,EAAE,KAAKzD,MAAL,CAAYsD,MAAZ,CAAmBE,aAAnB,CAAiCC,cADtC;AAEXC,iCAAiB,EAAE,KAAK1D,MAAL,CAAYsD,MAAZ,CAAmBE,aAAnB,CAAiCE,iBAFzC;AAGXC,wBAAQ,EAAE,KAAK3D,MAAL,CAAYsD,MAAZ,CAAmBE,aAAnB,CAAiCG,QAHhC;AAIXrD,6BAAa,EAAE,KAAKA;AAJT,eAVZ;AAgBHsD,6BAAe,EAAE,KAAK1D,aAhBnB;AAiBH2D,8BAAgB,EAAE,KAAKC,aAjBpB;AAkBHC,8BAAgB,EAAE,KAAKC,cAlBpB;AAmBHzB,oCAAsB,EAAEA,sBAnBrB;AAoBH0B,yBAAW,EAAE;AACTC,mBAAG,EAAEC,gBAAgB,CAACC,QADb;AAETC,uBAAO,EAAEA,OAFA;AAGTC,mBAAG,EAAE,EAHI;AAITC,kBAAE,EAAE;AAJK;AApBV,aAAP;;;;AA2BH,GA/Be;;;;;;;AAqCN9D,wEAAV,UAA0C+D,IAA1C,EAAwDC,eAAxD,EAA0FC,oBAA1F,EAAuH;AACnH,SAAKvE,MAAL,CAAYQ,OAAZ,CAAoB,wCAApB,EAA8D+D,oBAA9D,EADmH;;AAGnH,QAAMC,YAAY,GAAoC3C,SAAS,CAAC4C,mBAAV,CAA8BJ,IAA9B,CAAtD;;AACA,QAAI,CAACG,YAAY,CAACE,KAAlB,EAAyB;AACrB,YAAMC,gBAAgB,CAACC,kCAAjB,EAAN;AACH;;AAED,QAAMC,gBAAgB,GAAGC,oBAAoB,CAACC,0BAArB,CAAgD,KAAKhF,aAArD,EAAoEyE,YAAY,CAACE,KAAjF,CAAzB;;AACA,QAAI,CAACG,gBAAL,EAAuB;AACnB,YAAMF,gBAAgB,CAACK,6BAAjB,EAAN;AACH;;AAED,QAAIH,gBAAgB,CAACP,eAAjB,KAAqCA,eAAzC,EAA0D;AACtD,YAAMK,gBAAgB,CAACM,uCAAjB,EAAN;AACH;;AAED,SAAKjF,MAAL,CAAYQ,OAAZ,CAAoB,2BAApB,EAAiD+D,oBAAjD;AACA,WAAOC,YAAY,CAACE,KAApB;AACH,GAnBS;;;;;;;;AA0BMpE,+DAAhB,UAAuCoC,gBAAvC,EAAkEJ,wBAAlE,EAA8G;;;;;;AAC1G,iBAAKtC,MAAL,CAAYQ,OAAZ,CAAoB,+BAApB;AACM0E,4BAAgB,GAAqB;AACvCC,0BAAY,EAAE,KAAKtF,MAAL,CAAYoC,IAAZ,CAAiBkD,YADQ;AAEvCC,8BAAgB,EAAE,KAAKvF,MAAL,CAAYoC,IAAZ,CAAiBmD,gBAFI;AAGvCC,oCAAsB,EAAE,KAAKxF,MAAL,CAAYoC,IAAZ,CAAiBoD,sBAHF;AAIvCC,+BAAiB,EAAE,KAAKzF,MAAL,CAAYoC,IAAZ,CAAiBqD;AAJG,aAArC;AAQAC,yBAAa,GAAG7C,gBAAgB,GAAGA,gBAAH,GAAsB,KAAK7C,MAAL,CAAYoC,IAAZ,CAAiBc,SAAvE;AAGAyC,0BAAc,GAAGC,SAAS,CAACC,iBAAV,CAA6BH,aAA7B,EAA4CjD,wBAAwB,IAAI,KAAKzC,MAAL,CAAYoC,IAAZ,CAAiB0D,iBAAzF,CAAjB;AACN,iBAAK3F,MAAL,CAAYQ,OAAZ,CAAoB,yDAApB;AACO;AAAA;AAAA,cAAMoF,gBAAgB,CAACC,wBAAjB,CAA0CL,cAA1C,EAA0D,KAAK3F,MAAL,CAAYsD,MAAZ,CAAmBQ,aAA7E,EAA4F,KAAKE,cAAjG,EAAiHqB,gBAAjH,CAAN;;;AAAP;AAAA;AAAA,cAAOvE,SAAP;;;;AACH,GAhBe;;;;;;;;AAuBAL,uEAAhB,UAA+CC,OAA/C,EAAuG+D,eAAvG,EAAuI;;;;;;;AACnI,iBAAKtE,MAAL,CAAYQ,OAAZ,CAAoB,uCAApB;AACMK,uBAAW,GAAG,KAAKiF,cAAL,CAAoBvF,OAAO,CAACM,WAA5B,CAAd;AACAkF,wBAAY,GAAuB;AACrCzB,6BAAe,EAAEA;AADoB,aAAnC;AAGAI,iBAAK,GAAGsB,aAAa,CAACC,eAAd,CACV,KAAKlG,aADK,EAETQ,OAAO,IAAIA,OAAO,CAACmE,KAApB,IAA6BtD,SAAS,CAAC8E,YAF7B,EAGVH,YAHU,CAAR;;AAOC;AAAA;AAAA,cAAM,KAAKI,qBAAL,CAA2B5F,OAA3B,CAAN;;;AADD6F,4BAAgB,6DACfC,SADe,KAC0B;AAC5CxF,yBAAW,EAAEA,WAD+B;AAE5C6D,mBAAK,EAAEA,KAFqC;AAG5C4B,mBAAK,EAAE/F,OAAO,CAAC+F,KAAR,IAAiB,KAAKvG,aAAL,CAAmByB,aAAnB,EAHoB;AAI5C+E,0BAAY,EAAEC,YAAY,CAACC;AAJiB,aAD1B,EAAhB;AAQA/E,mBAAO,GAAGnB,OAAO,CAACmB,OAAR,IAAmB,KAAKmC,cAAL,CAAoB6C,gBAApB,EAA7B;;AACN,gBAAIhF,OAAJ,EAAa;AACT,mBAAK1B,MAAL,CAAYQ,OAAZ,CAAoB,mCAApB;AACA,mBAAKR,MAAL,CAAY2G,UAAZ,CAAuB,wCAAsCjF,OAA7D;AACA0E,8BAAgB,CAAC1E,OAAjB,GAA2BA,OAA3B;AACH;;;AAGD,gBAAIkF,WAAW,CAACC,OAAZ,CAAoBT,gBAAgB,CAACU,SAArC,KAAmD,CAACpF,OAAxD,EAAiE;AACvDqF,6BAAe,GAAG,KAAKlD,cAAL,CAAoBmD,kBAApB,EAAlB;;AACN,kBAAID,eAAJ,EAAqB;AACjBX,gCAAgB,CAACU,SAAjB,GAA6BC,eAA7B;AACH;AACJ;;AAED;AAAA;AAAA,cAAOX,gBAAP;;;;AACH,GApCe;;AAqCpB;AAxPA,EAAwDa","names":["__extends","config","storageImpl","browserCrypto","logger","eventHandler","navigationClient","correlationId","_super","_this","StandardInteractionClient","request","verbose","generatePkceCodes","generatedPkceParams","_a","authCodeRequest","redirectUri","code","codeVerifier","verifier","codeChallenge","challenge","codeChallengeMethod","Constants","S256_CODE_CHALLENGE_METHOD","logoutRequest","validLogoutRequest","createNewGuid","logoutHint","account","getLogoutHintFromIdTokenClaims","postLogoutRedirectUri","UrlString","getAbsoluteUrl","BrowserUtils","getCurrentUri","auth","idTokenClaims","login_hint","serverTelemetryManager","authorityUrl","requestAzureCloudOptions","getClientConfiguration","clientConfig","AuthorizationCodeClient","requestAuthority","getDiscoveredAuthority","discoveredAuthority","authOptions","clientId","authority","clientCapabilities","systemOptions","tokenRenewalOffsetSeconds","system","preventCorsPreflight","loggerOptions","loggerCallback","piiLoggingEnabled","logLevel","cryptoInterface","networkInterface","networkClient","storageInterface","browserStorage","libraryInfo","sku","BrowserConstants","MSAL_SKU","version","cpu","os","hash","interactionType","requestCorrelationId","serverParams","getDeserializedHash","state","BrowserAuthError","createHashDoesNotContainStateError","platformStateObj","BrowserProtocolUtils","extractBrowserRequestState","createUnableToParseStateError","createStateInteractionTypeMismatchError","authorityOptions","protocolMode","knownAuthorities","cloudDiscoveryMetadata","authorityMetadata","userAuthority","builtAuthority","Authority","generateAuthority","azureCloudOptions","AuthorityFactory","createDiscoveredInstance","getRedirectUri","browserState","ProtocolUtils","setRequestState","EMPTY_STRING","initializeBaseRequest","validatedRequest","_b","nonce","responseMode","ResponseMode","FRAGMENT","getActiveAccount","verbosePii","StringUtils","isEmpty","loginHint","legacyLoginHint","getLegacyLoginHint","BaseInteractionClient"],"sources":["C:\\Users\\empti\\OneDrive\\Desktop\\User_Interface\\user_interface_frontend\\node_modules\\@azure\\msal-browser\\src\\interaction_client\\StandardInteractionClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { ICrypto, Logger, ServerTelemetryManager, CommonAuthorizationCodeRequest, Constants, AuthorizationCodeClient, ClientConfiguration, AuthorityOptions, Authority, AuthorityFactory, ServerAuthorizationCodeResponse, UrlString, CommonEndSessionRequest, ProtocolUtils, ResponseMode, StringUtils, IdTokenClaims, AccountInfo, AzureCloudOptions } from \"@azure/msal-common\";\nimport { BaseInteractionClient } from \"./BaseInteractionClient\";\nimport { BrowserConfiguration } from \"../config/Configuration\";\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\nimport { BrowserCacheManager } from \"../cache/BrowserCacheManager\";\nimport { EventHandler } from \"../event/EventHandler\";\nimport { BrowserConstants, InteractionType } from \"../utils/BrowserConstants\";\nimport { version } from \"../packageMetadata\";\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\nimport { BrowserProtocolUtils, BrowserStateObject } from \"../utils/BrowserProtocolUtils\";\nimport { EndSessionRequest } from \"../request/EndSessionRequest\";\nimport { BrowserUtils } from \"../utils/BrowserUtils\";\nimport { INavigationClient } from \"../navigation/INavigationClient\";\nimport { RedirectRequest } from \"../request/RedirectRequest\";\nimport { PopupRequest } from \"../request/PopupRequest\";\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest\";\n\n/**\n * Defines the class structure and helper functions used by the \"standard\", non-brokered auth flows (popup, redirect, silent (RT), silent (iframe))\n */\nexport abstract class StandardInteractionClient extends BaseInteractionClient {\n    protected navigationClient: INavigationClient;\n\n    constructor(config: BrowserConfiguration, storageImpl: BrowserCacheManager, browserCrypto: ICrypto, logger: Logger, eventHandler: EventHandler, navigationClient: INavigationClient, correlationId?: string) {\n        super(config, storageImpl, browserCrypto, logger, eventHandler, correlationId);\n        this.navigationClient = navigationClient;\n    }\n\n    /**\n     * Generates an auth code request tied to the url request.\n     * @param request\n     */\n    protected async initializeAuthorizationCodeRequest(request: AuthorizationUrlRequest): Promise<CommonAuthorizationCodeRequest> {\n        this.logger.verbose(\"initializeAuthorizationRequest called\", request.correlationId);\n        const generatedPkceParams = await this.browserCrypto.generatePkceCodes();\n\n        const authCodeRequest: CommonAuthorizationCodeRequest = {\n            ...request,\n            redirectUri: request.redirectUri,\n            code: \"\",\n            codeVerifier: generatedPkceParams.verifier\n        };\n\n        request.codeChallenge = generatedPkceParams.challenge;\n        request.codeChallengeMethod = Constants.S256_CODE_CHALLENGE_METHOD;\n\n        return authCodeRequest;\n    }\n\n    /**\n     * Initializer for the logout request.\n     * @param logoutRequest\n     */\n    protected initializeLogoutRequest(logoutRequest?: EndSessionRequest): CommonEndSessionRequest {\n        this.logger.verbose(\"initializeLogoutRequest called\", logoutRequest?.correlationId);\n\n        const validLogoutRequest: CommonEndSessionRequest = {\n            correlationId: this.browserCrypto.createNewGuid(),\n            ...logoutRequest\n        };\n\n        /**\n         * Set logout_hint to be login_hint from ID Token Claims if present\n         * and logoutHint attribute wasn't manually set in logout request\n         */\n        if (logoutRequest) {\n            // If logoutHint isn't set and an account was passed in, try to extract logoutHint from ID Token Claims\n            if (!logoutRequest.logoutHint) {\n                if(logoutRequest.account) {\n                    const logoutHint = this.getLogoutHintFromIdTokenClaims(logoutRequest.account);\n                    if (logoutHint) {\n                        this.logger.verbose(\"Setting logoutHint to login_hint ID Token Claim value for the account provided\");\n                        validLogoutRequest.logoutHint = logoutHint;\n                    }\n                } else {\n                    this.logger.verbose(\"logoutHint was not set and account was not passed into logout request, logoutHint will not be set\");\n                }\n            } else {\n                this.logger.verbose(\"logoutHint has already been set in logoutRequest\");\n            }\n        } else {\n            this.logger.verbose(\"logoutHint will not be set since no logout request was configured\");\n        }\n\n        /*\n         * Only set redirect uri if logout request isn't provided or the set uri isn't null.\n         * Otherwise, use passed uri, config, or current page.\n         */\n        if (!logoutRequest || logoutRequest.postLogoutRedirectUri !== null) {\n            if (logoutRequest && logoutRequest.postLogoutRedirectUri) {\n                this.logger.verbose(\"Setting postLogoutRedirectUri to uri set on logout request\", validLogoutRequest.correlationId);\n                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(logoutRequest.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\n            } else if (this.config.auth.postLogoutRedirectUri === null) {\n                this.logger.verbose(\"postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect\", validLogoutRequest.correlationId);\n            } else if (this.config.auth.postLogoutRedirectUri) {\n                this.logger.verbose(\"Setting postLogoutRedirectUri to configured uri\", validLogoutRequest.correlationId);\n                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\n            } else {\n                this.logger.verbose(\"Setting postLogoutRedirectUri to current page\", validLogoutRequest.correlationId);\n                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(BrowserUtils.getCurrentUri(), BrowserUtils.getCurrentUri());\n            }\n        } else {\n            this.logger.verbose(\"postLogoutRedirectUri passed as null, not setting post logout redirect uri\", validLogoutRequest.correlationId);\n        }\n\n        return validLogoutRequest;\n    }\n\n    /**\n     * Parses login_hint ID Token Claim out of AccountInfo object to be used as\n     * logout_hint in end session request.\n     * @param account\n     */\n    protected getLogoutHintFromIdTokenClaims(account: AccountInfo): string | null {\n        const idTokenClaims: IdTokenClaims | undefined = account.idTokenClaims;\n        if (idTokenClaims) {\n            if (idTokenClaims.login_hint) {\n                return idTokenClaims.login_hint;\n            } else {\n                this.logger.verbose(\"The ID Token Claims tied to the provided account do not contain a login_hint claim, logoutHint will not be added to logout request\");\n            }\n        } else {\n            this.logger.verbose(\"The provided account does not contain ID Token Claims, logoutHint will not be added to logout request\");\n        }\n\n        return null;\n    }\n\n    /**\n     * Creates an Authorization Code Client with the given authority, or the default authority.\n     * @param serverTelemetryManager\n     * @param authorityUrl\n     */\n    protected async createAuthCodeClient(serverTelemetryManager: ServerTelemetryManager, authorityUrl?: string, requestAzureCloudOptions?: AzureCloudOptions): Promise<AuthorizationCodeClient> {\n        // Create auth module.\n        const clientConfig = await this.getClientConfiguration(serverTelemetryManager, authorityUrl, requestAzureCloudOptions);\n        return new AuthorizationCodeClient(clientConfig);\n    }\n\n    /**\n     * Creates a Client Configuration object with the given request authority, or the default authority.\n     * @param serverTelemetryManager\n     * @param requestAuthority\n     * @param requestCorrelationId\n     */\n    protected async getClientConfiguration(serverTelemetryManager: ServerTelemetryManager, requestAuthority?: string, requestAzureCloudOptions?: AzureCloudOptions): Promise<ClientConfiguration> {\n        this.logger.verbose(\"getClientConfiguration called\");\n        const discoveredAuthority = await this.getDiscoveredAuthority(requestAuthority, requestAzureCloudOptions);\n\n        return {\n            authOptions: {\n                clientId: this.config.auth.clientId,\n                authority: discoveredAuthority,\n                clientCapabilities: this.config.auth.clientCapabilities\n            },\n            systemOptions: {\n                tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds,\n                preventCorsPreflight: true\n            },\n            loggerOptions: {\n                loggerCallback: this.config.system.loggerOptions.loggerCallback,\n                piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,\n                logLevel: this.config.system.loggerOptions.logLevel,\n                correlationId: this.correlationId\n            },\n            cryptoInterface: this.browserCrypto,\n            networkInterface: this.networkClient,\n            storageInterface: this.browserStorage,\n            serverTelemetryManager: serverTelemetryManager,\n            libraryInfo: {\n                sku: BrowserConstants.MSAL_SKU,\n                version: version,\n                cpu: \"\",\n                os: \"\"\n            }\n        };\n    }\n\n    /**\n     * @param hash\n     * @param interactionType\n     */\n    protected validateAndExtractStateFromHash(hash: string, interactionType: InteractionType, requestCorrelationId?: string): string {\n        this.logger.verbose(\"validateAndExtractStateFromHash called\", requestCorrelationId);\n        // Deserialize hash fragment response parameters.\n        const serverParams: ServerAuthorizationCodeResponse = UrlString.getDeserializedHash(hash);\n        if (!serverParams.state) {\n            throw BrowserAuthError.createHashDoesNotContainStateError();\n        }\n\n        const platformStateObj = BrowserProtocolUtils.extractBrowserRequestState(this.browserCrypto, serverParams.state);\n        if (!platformStateObj) {\n            throw BrowserAuthError.createUnableToParseStateError();\n        }\n\n        if (platformStateObj.interactionType !== interactionType) {\n            throw BrowserAuthError.createStateInteractionTypeMismatchError();\n        }\n\n        this.logger.verbose(\"Returning state from hash\", requestCorrelationId);\n        return serverParams.state;\n    }\n\n    /**\n     * Used to get a discovered version of the default authority.\n     * @param requestAuthority\n     * @param requestCorrelationId\n     */\n    protected async getDiscoveredAuthority(requestAuthority?: string, requestAzureCloudOptions?: AzureCloudOptions): Promise<Authority> {\n        this.logger.verbose(\"getDiscoveredAuthority called\");\n        const authorityOptions: AuthorityOptions = {\n            protocolMode: this.config.auth.protocolMode,\n            knownAuthorities: this.config.auth.knownAuthorities,\n            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n            authorityMetadata: this.config.auth.authorityMetadata,\n        };\n\n        // build authority string based on auth params, precedence - azureCloudInstance + tenant >> authority\n        const userAuthority = requestAuthority ? requestAuthority : this.config.auth.authority;\n\n        // fall back to the authority from config\n        const builtAuthority = Authority.generateAuthority( userAuthority, requestAzureCloudOptions || this.config.auth.azureCloudOptions);\n        this.logger.verbose(\"Creating discovered authority with configured authority\");\n        return await AuthorityFactory.createDiscoveredInstance(builtAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions);\n    }\n\n    /**\n     * Helper to initialize required request parameters for interactive APIs and ssoSilent()\n     * @param request\n     * @param interactionType\n     */\n    protected async initializeAuthorizationRequest(request: RedirectRequest|PopupRequest|SsoSilentRequest, interactionType: InteractionType): Promise<AuthorizationUrlRequest> {\n        this.logger.verbose(\"initializeAuthorizationRequest called\");\n        const redirectUri = this.getRedirectUri(request.redirectUri);\n        const browserState: BrowserStateObject = {\n            interactionType: interactionType\n        };\n        const state = ProtocolUtils.setRequestState(\n            this.browserCrypto,\n            (request && request.state)|| Constants.EMPTY_STRING,\n            browserState\n        );\n\n        const validatedRequest: AuthorizationUrlRequest = {\n            ...await this.initializeBaseRequest(request),\n            redirectUri: redirectUri,\n            state: state,\n            nonce: request.nonce || this.browserCrypto.createNewGuid(),\n            responseMode: ResponseMode.FRAGMENT\n        };\n\n        const account = request.account || this.browserStorage.getActiveAccount();\n        if (account) {\n            this.logger.verbose(\"Setting validated request account\");\n            this.logger.verbosePii(`Setting validated request account: ${account}`);\n            validatedRequest.account = account;\n        }\n\n        // Check for ADAL/MSAL v1 SSO\n        if (StringUtils.isEmpty(validatedRequest.loginHint) && !account) {\n            const legacyLoginHint = this.browserStorage.getLegacyLoginHint();\n            if (legacyLoginHint) {\n                validatedRequest.loginHint = legacyLoginHint;\n            }\n        }\n\n        return validatedRequest;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}