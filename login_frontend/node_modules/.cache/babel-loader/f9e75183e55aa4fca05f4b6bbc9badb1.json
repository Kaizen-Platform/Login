{"ast":null,"code":"/*! @azure/msal-browser v2.22.0 2022-02-08 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BrowserAuthError, BrowserAuthErrorMessage } from '../error/BrowserAuthError.js';\nimport { DatabaseStorage } from './DatabaseStorage.js';\nimport { MemoryStorage } from './MemoryStorage.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\r\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\r\n */\n\nvar AsyncMemoryStorage =\n/** @class */\nfunction () {\n  function AsyncMemoryStorage(logger) {\n    this.inMemoryCache = new MemoryStorage();\n    this.indexedDBCache = new DatabaseStorage();\n    this.logger = logger;\n  }\n\n  AsyncMemoryStorage.prototype.handleDatabaseAccessError = function (error) {\n    if (error instanceof BrowserAuthError && error.errorCode === BrowserAuthErrorMessage.databaseUnavailable.code) {\n      this.logger.error(\"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\");\n    }\n  };\n  /**\r\n   * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\r\n   * storage object if item isn't found in-memory.\r\n   * @param key\r\n   */\n\n\n  AsyncMemoryStorage.prototype.getItem = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var item, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            item = this.inMemoryCache.getItem(key);\n            if (!!item) return [3\n            /*break*/\n            , 4];\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            this.logger.verbose(\"Queried item not found in in-memory cache, now querying persistent storage.\");\n            return [4\n            /*yield*/\n            , this.indexedDBCache.getItem(key)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 3:\n            e_1 = _a.sent();\n            this.handleDatabaseAccessError(e_1);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            , item];\n        }\n      });\n    });\n  };\n  /**\r\n   * Sets the item in the in-memory cache and then tries to set it in the asynchronous\r\n   * storage object with the given key.\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  AsyncMemoryStorage.prototype.setItem = function (key, value) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.inMemoryCache.setItem(key, value);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.indexedDBCache.setItem(key, value)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_2 = _a.sent();\n            this.handleDatabaseAccessError(e_2);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\r\n   * @param key\r\n   */\n\n\n  AsyncMemoryStorage.prototype.removeItem = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.inMemoryCache.removeItem(key);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.indexedDBCache.removeItem(key)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_3 = _a.sent();\n            this.handleDatabaseAccessError(e_3);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the\r\n   * asynchronous storage object.\r\n   */\n\n\n  AsyncMemoryStorage.prototype.getKeys = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var cacheKeys, e_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            cacheKeys = this.inMemoryCache.getKeys();\n            if (!(cacheKeys.length === 0)) return [3\n            /*break*/\n            , 4];\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            this.logger.verbose(\"In-memory cache is empty, now querying persistent storage.\");\n            return [4\n            /*yield*/\n            , this.indexedDBCache.getKeys()];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 3:\n            e_4 = _a.sent();\n            this.handleDatabaseAccessError(e_4);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            , cacheKeys];\n        }\n      });\n    });\n  };\n  /**\r\n   * Returns true or false if the given key is present in the cache.\r\n   * @param key\r\n   */\n\n\n  AsyncMemoryStorage.prototype.containsKey = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      var containsKey, e_5;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            containsKey = this.inMemoryCache.containsKey(key);\n            if (!!containsKey) return [3\n            /*break*/\n            , 4];\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            this.logger.verbose(\"Key not found in in-memory cache, now querying persistent storage.\");\n            return [4\n            /*yield*/\n            , this.indexedDBCache.containsKey(key)];\n\n          case 2:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 3:\n            e_5 = _a.sent();\n            this.handleDatabaseAccessError(e_5);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            , containsKey];\n        }\n      });\n    });\n  };\n  /**\r\n   * Clears in-memory Map and tries to delete the IndexedDB database.\r\n   */\n\n\n  AsyncMemoryStorage.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_6;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.inMemoryCache.clear();\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.indexedDBCache.deleteDatabase()];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_6 = _a.sent();\n            this.handleDatabaseAccessError(e_6);\n            return [3\n            /*break*/\n            , 4];\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return AsyncMemoryStorage;\n}();\n\nexport { AsyncMemoryStorage };","map":{"version":3,"mappings":"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","names":["logger","inMemoryCache","MemoryStorage","indexedDBCache","DatabaseStorage","AsyncMemoryStorage","error","BrowserAuthError","errorCode","BrowserAuthErrorMessage","databaseUnavailable","code","key","item","getItem","verbose","_a","handleDatabaseAccessError","e_1","value","setItem","e_2","removeItem","e_3","cacheKeys","getKeys","length","e_4","containsKey","e_5","clear","deleteDatabase","e_6"],"sources":["C:\\Users\\empti\\OneDrive\\Desktop\\User_Interface\\user_interface_frontend\\node_modules\\@azure\\msal-browser\\src\\cache\\AsyncMemoryStorage.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Logger } from \"@azure/msal-common\";\nimport { BrowserAuthError, BrowserAuthErrorMessage } from \"../error/BrowserAuthError\";\nimport { DatabaseStorage } from \"./DatabaseStorage\";\nimport { IAsyncStorage } from \"./IAsyncMemoryStorage\";\nimport { MemoryStorage } from \"./MemoryStorage\";\n\n/**\n * This class allows MSAL to store artifacts asynchronously using the DatabaseStorage IndexedDB wrapper,\n * backed up with the more volatile MemoryStorage object for cases in which IndexedDB may be unavailable.\n */\nexport class AsyncMemoryStorage<T> implements IAsyncStorage<T> {\n    private inMemoryCache: MemoryStorage<T>;\n    private indexedDBCache: DatabaseStorage<T>;\n    private logger: Logger;\n\n    constructor(logger: Logger) {\n        this.inMemoryCache = new MemoryStorage<T>();\n        this.indexedDBCache = new DatabaseStorage<T>();\n        this.logger = logger;\n    }\n\n    private handleDatabaseAccessError(error: unknown): void {\n        if (error instanceof BrowserAuthError && error.errorCode === BrowserAuthErrorMessage.databaseUnavailable.code) {\n            this.logger.error(\"Could not access persistent storage. This may be caused by browser privacy features which block persistent storage in third-party contexts.\");\n        }\n    }\n    /**\n     * Get the item matching the given key. Tries in-memory cache first, then in the asynchronous\n     * storage object if item isn't found in-memory.\n     * @param key \n     */\n    async getItem(key: string): Promise<T | null> {\n        const item = this.inMemoryCache.getItem(key);\n        if(!item) {\n            try {\n                this.logger.verbose(\"Queried item not found in in-memory cache, now querying persistent storage.\");\n                return await this.indexedDBCache.getItem(key);\n            } catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return item;\n    }\n\n    /**\n     * Sets the item in the in-memory cache and then tries to set it in the asynchronous\n     * storage object with the given key.\n     * @param key \n     * @param value \n     */\n    async setItem(key: string, value: T): Promise<void> {\n        this.inMemoryCache.setItem(key, value);\n        try {\n            await this.indexedDBCache.setItem(key, value);\n        } catch (e) {\n            this.handleDatabaseAccessError(e);\n        }\n    }\n\n    /**\n     * Removes the item matching the key from the in-memory cache, then tries to remove it from the asynchronous storage object.\n     * @param key \n     */\n    async removeItem(key: string): Promise<void> {\n        this.inMemoryCache.removeItem(key);\n        try {\n            await this.indexedDBCache.removeItem(key);\n        } catch (e) {\n            this.handleDatabaseAccessError(e);\n        }\n    }\n\n    /**\n     * Get all the keys from the in-memory cache as an iterable array of strings. If no keys are found, query the keys in the \n     * asynchronous storage object.\n     */\n    async getKeys(): Promise<string[]> {\n        const cacheKeys = this.inMemoryCache.getKeys();\n        if (cacheKeys.length === 0) {\n            try {\n                this.logger.verbose(\"In-memory cache is empty, now querying persistent storage.\");\n                return await this.indexedDBCache.getKeys();\n            } catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return cacheKeys;\n    }\n\n    /**\n     * Returns true or false if the given key is present in the cache.\n     * @param key \n     */\n    async containsKey(key: string): Promise<boolean> {\n        const containsKey = this.inMemoryCache.containsKey(key);\n        if(!containsKey) {\n            try {\n                this.logger.verbose(\"Key not found in in-memory cache, now querying persistent storage.\");\n                return await this.indexedDBCache.containsKey(key);\n            } catch (e) {\n                this.handleDatabaseAccessError(e);\n            }\n        }\n        return containsKey;\n    }\n\n    /**\n     * Clears in-memory Map and tries to delete the IndexedDB database.\n     */\n    async clear(): Promise<void> {\n        this.inMemoryCache.clear();\n        try {\n            await this.indexedDBCache.deleteDatabase();\n        } catch (e) {\n            this.handleDatabaseAccessError(e);\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}