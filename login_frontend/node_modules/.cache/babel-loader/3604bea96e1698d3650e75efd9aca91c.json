{"ast":null,"code":"/*! @azure/msal-browser v2.22.0 2022-02-08 */\n'use strict';\n\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { OIDC_DEFAULT_SCOPES, AuthError, ThrottlingUtils, UrlString } from '@azure/msal-common';\nimport { StandardInteractionClient } from './StandardInteractionClient.js';\nimport { PopupUtils } from '../utils/PopupUtils.js';\nimport { EventType } from '../event/EventType.js';\nimport { InteractionType, ApiId } from '../utils/BrowserConstants.js';\nimport { PopupHandler } from '../interaction_handler/PopupHandler.js';\nimport { BrowserUtils } from '../utils/BrowserUtils.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar PopupClient =\n/** @class */\nfunction (_super) {\n  __extends(PopupClient, _super);\n\n  function PopupClient() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Acquires tokens by opening a popup window to the /authorize endpoint of the authority\r\n   * @param request\r\n   */\n\n\n  PopupClient.prototype.acquireToken = function (request) {\n    try {\n      var popupName = PopupUtils.generatePopupName(this.config.auth.clientId, request.scopes || OIDC_DEFAULT_SCOPES, request.authority || this.config.auth.authority, this.correlationId);\n      var popupWindowAttributes = request.popupWindowAttributes || {}; // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n\n      if (this.config.system.asyncPopups) {\n        this.logger.verbose(\"asyncPopups set to true, acquiring token\"); // Passes on popup position and dimensions if in request\n\n        return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes);\n      } else {\n        // asyncPopups flag is set to false. Opens popup before acquiring token.\n        this.logger.verbose(\"asyncPopup set to false, opening popup before acquiring token\");\n        var popup = PopupUtils.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes, this.logger);\n        return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes, popup);\n      }\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n  /**\r\n   * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server\r\n   * @param logoutRequest\r\n   */\n\n\n  PopupClient.prototype.logout = function (logoutRequest) {\n    try {\n      this.logger.verbose(\"logoutPopup called\");\n      var validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n      var popupName = PopupUtils.generateLogoutPopupName(this.config.auth.clientId, validLogoutRequest);\n      var authority = logoutRequest && logoutRequest.authority;\n      var mainWindowRedirectUri = logoutRequest && logoutRequest.mainWindowRedirectUri;\n      var popupWindowAttributes = (logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.popupWindowAttributes) || {}; // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n\n      if (this.config.system.asyncPopups) {\n        this.logger.verbose(\"asyncPopups set to true\"); // Passes on popup position and dimensions if in request\n\n        return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, undefined, mainWindowRedirectUri);\n      } else {\n        // asyncPopups flag is set to false. Opens popup before logging out.\n        this.logger.verbose(\"asyncPopup set to false, opening popup\");\n        var popup = PopupUtils.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes, this.logger);\n        return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, popup, mainWindowRedirectUri);\n      }\n    } catch (e) {\n      // Since this function is synchronous we need to reject\n      return Promise.reject(e);\n    }\n  };\n  /**\r\n   * Helper which obtains an access_token for your API via opening a popup window in the user's browser\r\n   * @param validRequest\r\n   * @param popupName\r\n   * @param popup\r\n   * @param popupWindowAttributes\r\n   *\r\n   * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\r\n   */\n\n\n  PopupClient.prototype.acquireTokenPopupAsync = function (request, popupName, popupWindowAttributes, popup) {\n    return __awaiter(this, void 0, void 0, function () {\n      var serverTelemetryManager, validRequest, authCodeRequest, authClient, navigateUrl, interactionHandler, popupParameters, popupWindow, hash, state, result, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"acquireTokenPopupAsync called\");\n            serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenPopup);\n            return [4\n            /*yield*/\n            , this.initializeAuthorizationRequest(request, InteractionType.Popup)];\n\n          case 1:\n            validRequest = _a.sent();\n            this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || \"\", validRequest.account || null);\n            _a.label = 2;\n\n          case 2:\n            _a.trys.push([2, 8,, 9]);\n\n            return [4\n            /*yield*/\n            , this.initializeAuthorizationCodeRequest(validRequest)];\n\n          case 3:\n            authCodeRequest = _a.sent();\n            return [4\n            /*yield*/\n            , this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions)];\n\n          case 4:\n            authClient = _a.sent();\n            this.logger.verbose(\"Auth code client created\");\n            return [4\n            /*yield*/\n            , authClient.getAuthCodeUrl(validRequest)];\n\n          case 5:\n            navigateUrl = _a.sent();\n            interactionHandler = new PopupHandler(authClient, this.browserStorage, authCodeRequest, this.logger);\n            popupParameters = {\n              popup: popup,\n              popupName: popupName,\n              popupWindowAttributes: popupWindowAttributes\n            };\n            popupWindow = interactionHandler.initiateAuthRequest(navigateUrl, popupParameters);\n            this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {\n              popupWindow: popupWindow\n            }, null);\n            return [4\n            /*yield*/\n            , interactionHandler.monitorPopupForHash(popupWindow)];\n\n          case 6:\n            hash = _a.sent();\n            state = this.validateAndExtractStateFromHash(hash, InteractionType.Popup, validRequest.correlationId); // Remove throttle if it exists\n\n            ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, authCodeRequest);\n            return [4\n            /*yield*/\n            , interactionHandler.handleCodeResponseFromHash(hash, state, authClient.authority, this.networkClient)];\n\n          case 7:\n            result = _a.sent();\n            return [2\n            /*return*/\n            , result];\n\n          case 8:\n            e_1 = _a.sent();\n\n            if (popup) {\n              // Close the synchronous popup if an error is thrown before the window unload event is registered\n              popup.close();\n            }\n\n            if (e_1 instanceof AuthError) {\n              e_1.setCorrelationId(this.correlationId);\n            }\n\n            serverTelemetryManager.cacheFailedRequest(e_1);\n            this.browserStorage.cleanRequestByState(validRequest.state);\n            throw e_1;\n\n          case 9:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   *\r\n   * @param validRequest\r\n   * @param popupName\r\n   * @param requestAuthority\r\n   * @param popup\r\n   * @param mainWindowRedirectUri\r\n   * @param popupWindowAttributes\r\n   */\n\n\n  PopupClient.prototype.logoutPopupAsync = function (validRequest, popupName, popupWindowAttributes, requestAuthority, popup, mainWindowRedirectUri) {\n    return __awaiter(this, void 0, void 0, function () {\n      var serverTelemetryManager, authClient, logoutUri, popupUtils, popupWindow, e_2, navigationOptions, absoluteUrl, e_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"logoutPopupAsync called\");\n            this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Popup, validRequest);\n            serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logoutPopup);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 8,, 9]); // Clear cache on logout\n\n\n            return [4\n            /*yield*/\n            , this.clearCacheOnLogout(validRequest.account)];\n\n          case 2:\n            // Clear cache on logout\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , this.createAuthCodeClient(serverTelemetryManager, requestAuthority)];\n\n          case 3:\n            authClient = _a.sent();\n            this.logger.verbose(\"Auth code client created\");\n            logoutUri = authClient.getLogoutUri(validRequest);\n            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);\n            popupUtils = new PopupUtils(this.browserStorage, this.logger);\n            popupWindow = popupUtils.openPopup(logoutUri, {\n              popupName: popupName,\n              popupWindowAttributes: popupWindowAttributes,\n              popup: popup\n            });\n            this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {\n              popupWindow: popupWindow\n            }, null);\n            _a.label = 4;\n\n          case 4:\n            _a.trys.push([4, 6,, 7]); // Don't care if this throws an error (User Cancelled)\n\n\n            return [4\n            /*yield*/\n            , popupUtils.monitorPopupForSameOrigin(popupWindow)];\n\n          case 5:\n            // Don't care if this throws an error (User Cancelled)\n            _a.sent();\n\n            this.logger.verbose(\"Popup successfully redirected to postLogoutRedirectUri\");\n            return [3\n            /*break*/\n            , 7];\n\n          case 6:\n            e_2 = _a.sent();\n            this.logger.verbose(\"Error occurred while monitoring popup for same origin. Session on server may remain active. Error: \" + e_2);\n            return [3\n            /*break*/\n            , 7];\n\n          case 7:\n            popupUtils.cleanPopup(popupWindow);\n\n            if (mainWindowRedirectUri) {\n              navigationOptions = {\n                apiId: ApiId.logoutPopup,\n                timeout: this.config.system.redirectNavigationTimeout,\n                noHistory: false\n              };\n              absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, BrowserUtils.getCurrentUri());\n              this.logger.verbose(\"Redirecting main window to url specified in the request\");\n              this.logger.verbosePii(\"Redirecting main window to: \" + absoluteUrl);\n              this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);\n            } else {\n              this.logger.verbose(\"No main window navigation requested\");\n            }\n\n            return [3\n            /*break*/\n            , 9];\n\n          case 8:\n            e_3 = _a.sent();\n\n            if (popup) {\n              // Close the synchronous popup if an error is thrown before the window unload event is registered\n              popup.close();\n            }\n\n            if (e_3 instanceof AuthError) {\n              e_3.setCorrelationId(this.correlationId);\n            }\n\n            this.browserStorage.setInteractionInProgress(false);\n            this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Popup, null, e_3);\n            this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n            serverTelemetryManager.cacheFailedRequest(e_3);\n            throw e_3;\n\n          case 9:\n            this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return PopupClient;\n}(StandardInteractionClient);\n\nexport { PopupClient };","map":{"version":3,"mappings":"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","names":["__extends","PopupClient","request","popupName","PopupUtils","generatePopupName","config","auth","clientId","scopes","OIDC_DEFAULT_SCOPES","authority","correlationId","popupWindowAttributes","system","asyncPopups","logger","verbose","acquireTokenPopupAsync","popup","openSizedPopup","e","Promise","reject","logoutRequest","validLogoutRequest","initializeLogoutRequest","generateLogoutPopupName","mainWindowRedirectUri","logoutPopupAsync","undefined","serverTelemetryManager","initializeServerTelemetryManager","ApiId","acquireTokenPopup","initializeAuthorizationRequest","InteractionType","Popup","validRequest","_a","browserStorage","updateCacheEntries","state","nonce","loginHint","account","initializeAuthorizationCodeRequest","authCodeRequest","createAuthCodeClient","azureCloudOptions","authClient","getAuthCodeUrl","navigateUrl","interactionHandler","PopupHandler","popupParameters","popupWindow","initiateAuthRequest","eventHandler","emitEvent","EventType","POPUP_OPENED","monitorPopupForHash","hash","validateAndExtractStateFromHash","ThrottlingUtils","removeThrottle","handleCodeResponseFromHash","networkClient","result","close","e_1","AuthError","setCorrelationId","cacheFailedRequest","cleanRequestByState","requestAuthority","LOGOUT_START","logoutPopup","clearCacheOnLogout","logoutUri","getLogoutUri","LOGOUT_SUCCESS","popupUtils","openPopup","monitorPopupForSameOrigin","e_2","cleanPopup","navigationOptions","apiId","timeout","redirectNavigationTimeout","noHistory","absoluteUrl","UrlString","getAbsoluteUrl","BrowserUtils","getCurrentUri","verbosePii","navigationClient","navigateInternal","e_3","setInteractionInProgress","LOGOUT_FAILURE","LOGOUT_END","StandardInteractionClient"],"sources":["C:\\Users\\empti\\OneDrive\\Desktop\\User_Interface\\user_interface_frontend\\node_modules\\@azure\\msal-browser\\src\\interaction_client\\PopupClient.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AuthenticationResult, CommonAuthorizationCodeRequest, AuthorizationCodeClient, ThrottlingUtils, CommonEndSessionRequest, UrlString, AuthError, OIDC_DEFAULT_SCOPES } from \"@azure/msal-common\";\nimport { StandardInteractionClient } from \"./StandardInteractionClient\";\nimport { PopupWindowAttributes, PopupUtils } from \"../utils/PopupUtils\";\nimport { EventType } from \"../event/EventType\";\nimport { InteractionType, ApiId } from \"../utils/BrowserConstants\";\nimport { PopupHandler, PopupParams } from \"../interaction_handler/PopupHandler\";\nimport { EndSessionPopupRequest } from \"../request/EndSessionPopupRequest\";\nimport { NavigationOptions } from \"../navigation/NavigationOptions\";\nimport { BrowserUtils } from \"../utils/BrowserUtils\";\nimport { PopupRequest } from \"../request/PopupRequest\";\n\nexport class PopupClient extends StandardInteractionClient {\n    /**\n     * Acquires tokens by opening a popup window to the /authorize endpoint of the authority\n     * @param request\n     */\n    acquireToken(request: PopupRequest): Promise<AuthenticationResult> {\n        try {\n            const popupName = PopupUtils.generatePopupName(this.config.auth.clientId, request.scopes || OIDC_DEFAULT_SCOPES, request.authority || this.config.auth.authority, this.correlationId);\n            const popupWindowAttributes = request.popupWindowAttributes || {};\n\n            // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n            if (this.config.system.asyncPopups) {\n                this.logger.verbose(\"asyncPopups set to true, acquiring token\");\n                // Passes on popup position and dimensions if in request\n                return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes);\n            } else {\n                // asyncPopups flag is set to false. Opens popup before acquiring token.\n                this.logger.verbose(\"asyncPopup set to false, opening popup before acquiring token\");\n                const popup = PopupUtils.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes, this.logger);\n                return this.acquireTokenPopupAsync(request, popupName, popupWindowAttributes, popup);\n            }\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    }\n\n    /**\n     * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server\n     * @param logoutRequest\n     */\n    logout(logoutRequest?: EndSessionPopupRequest): Promise<void> {\n        try {\n            this.logger.verbose(\"logoutPopup called\");\n            const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n\n            const popupName = PopupUtils.generateLogoutPopupName(this.config.auth.clientId, validLogoutRequest);\n            const authority = logoutRequest && logoutRequest.authority;\n            const mainWindowRedirectUri = logoutRequest && logoutRequest.mainWindowRedirectUri;\n            const popupWindowAttributes = logoutRequest?.popupWindowAttributes || {};\n\n            // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n            if (this.config.system.asyncPopups) {\n                this.logger.verbose(\"asyncPopups set to true\");\n                // Passes on popup position and dimensions if in request\n                return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, undefined, mainWindowRedirectUri);\n            } else {\n                // asyncPopups flag is set to false. Opens popup before logging out.\n                this.logger.verbose(\"asyncPopup set to false, opening popup\");\n                const popup = PopupUtils.openSizedPopup(\"about:blank\", popupName, popupWindowAttributes, this.logger);\n                return this.logoutPopupAsync(validLogoutRequest, popupName, popupWindowAttributes, authority, popup, mainWindowRedirectUri);\n            }\n        } catch (e) {\n            // Since this function is synchronous we need to reject\n            return Promise.reject(e);\n        }\n    }\n\n    /**\n     * Helper which obtains an access_token for your API via opening a popup window in the user's browser\n     * @param validRequest\n     * @param popupName\n     * @param popup\n     * @param popupWindowAttributes\n     *\n     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\n     */\n    protected async acquireTokenPopupAsync(request: PopupRequest, popupName: string, popupWindowAttributes: PopupWindowAttributes, popup?: Window|null): Promise<AuthenticationResult> {\n        this.logger.verbose(\"acquireTokenPopupAsync called\");\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenPopup);\n        const validRequest = await this.initializeAuthorizationRequest(request, InteractionType.Popup);\n        this.browserStorage.updateCacheEntries(validRequest.state, validRequest.nonce, validRequest.authority, validRequest.loginHint || \"\", validRequest.account || null);\n\n        try {\n            // Create auth code request and generate PKCE params\n            const authCodeRequest: CommonAuthorizationCodeRequest = await this.initializeAuthorizationCodeRequest(validRequest);\n\n            // Initialize the client\n            const authClient: AuthorizationCodeClient = await this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.azureCloudOptions);\n            this.logger.verbose(\"Auth code client created\");\n\n            // Create acquire token url.\n            const navigateUrl = await authClient.getAuthCodeUrl(validRequest);\n\n            // Create popup interaction handler.\n            const interactionHandler = new PopupHandler(authClient, this.browserStorage, authCodeRequest, this.logger);\n\n            // Show the UI once the url has been created. Get the window handle for the popup.\n            const popupParameters: PopupParams = {\n                popup,\n                popupName,\n                popupWindowAttributes\n            };\n            const popupWindow: Window = interactionHandler.initiateAuthRequest(navigateUrl, popupParameters);\n            this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {popupWindow}, null);\n\n            // Monitor the window for the hash. Return the string value and close the popup when the hash is received. Default timeout is 60 seconds.\n            const hash = await interactionHandler.monitorPopupForHash(popupWindow);\n            const state = this.validateAndExtractStateFromHash(hash, InteractionType.Popup, validRequest.correlationId);\n\n            // Remove throttle if it exists\n            ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, authCodeRequest);\n\n            // Handle response from hash string.\n            const result = await interactionHandler.handleCodeResponseFromHash(hash, state, authClient.authority, this.networkClient);\n\n            return result;\n        } catch (e) {\n            if (popup) {\n                // Close the synchronous popup if an error is thrown before the window unload event is registered\n                popup.close();\n            }\n\n            if (e instanceof AuthError) {\n                e.setCorrelationId(this.correlationId);\n            }\n\n            serverTelemetryManager.cacheFailedRequest(e);\n            this.browserStorage.cleanRequestByState(validRequest.state);\n            throw e;\n        }\n    }\n\n    /**\n     *\n     * @param validRequest\n     * @param popupName\n     * @param requestAuthority\n     * @param popup\n     * @param mainWindowRedirectUri\n     * @param popupWindowAttributes\n     */\n    protected async logoutPopupAsync(validRequest: CommonEndSessionRequest, popupName: string, popupWindowAttributes: PopupWindowAttributes, requestAuthority?: string, popup?: Window|null, mainWindowRedirectUri?: string): Promise<void> {\n        this.logger.verbose(\"logoutPopupAsync called\");\n        this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Popup, validRequest);\n\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logoutPopup);\n\n        try {\n            // Clear cache on logout\n            await this.clearCacheOnLogout(validRequest.account);\n\n            // Initialize the client\n            const authClient = await this.createAuthCodeClient(serverTelemetryManager, requestAuthority);\n            this.logger.verbose(\"Auth code client created\");\n\n            // Create logout string and navigate user window to logout.\n            const logoutUri: string = authClient.getLogoutUri(validRequest);\n\n            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);\n\n            const popupUtils = new PopupUtils(this.browserStorage, this.logger);\n            // Open the popup window to requestUrl.\n            const popupWindow = popupUtils.openPopup(logoutUri, {popupName, popupWindowAttributes, popup});\n            this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {popupWindow}, null);\n\n            try {\n                // Don't care if this throws an error (User Cancelled)\n                await popupUtils.monitorPopupForSameOrigin(popupWindow);\n                this.logger.verbose(\"Popup successfully redirected to postLogoutRedirectUri\");\n            } catch (e) {\n                this.logger.verbose(`Error occurred while monitoring popup for same origin. Session on server may remain active. Error: ${e}`);\n            }\n\n            popupUtils.cleanPopup(popupWindow);\n\n            if (mainWindowRedirectUri) {\n                const navigationOptions: NavigationOptions = {\n                    apiId: ApiId.logoutPopup,\n                    timeout: this.config.system.redirectNavigationTimeout,\n                    noHistory: false\n                };\n                const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, BrowserUtils.getCurrentUri());\n\n                this.logger.verbose(\"Redirecting main window to url specified in the request\");\n                this.logger.verbosePii(`Redirecting main window to: ${absoluteUrl}`);\n                this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);\n            } else {\n                this.logger.verbose(\"No main window navigation requested\");\n            }\n        } catch (e) {\n            if (popup) {\n                // Close the synchronous popup if an error is thrown before the window unload event is registered\n                popup.close();\n            }\n\n            if (e instanceof AuthError) {\n                e.setCorrelationId(this.correlationId);\n            }\n\n            this.browserStorage.setInteractionInProgress(false);\n            this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Popup, null, e);\n            this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n            serverTelemetryManager.cacheFailedRequest(e);\n            throw e;\n        }\n\n        this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}