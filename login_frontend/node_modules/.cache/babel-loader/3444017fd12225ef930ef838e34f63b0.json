{"ast":null,"code":"/*! @azure/msal-browser v2.22.0 2022-02-08 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BrowserStringUtils } from '../utils/BrowserStringUtils.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { KEY_FORMAT_JWK } from '../utils/BrowserConstants.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * See here for more info on RsaHashedKeyGenParams: https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams\r\n */\n// RSA KeyGen Algorithm\n\nvar PKCS1_V15_KEYGEN_ALG = \"RSASSA-PKCS1-v1_5\"; // SHA-256 hashing algorithm\n\nvar S256_HASH_ALG = \"SHA-256\"; // MOD length for PoP tokens\n\nvar MODULUS_LENGTH = 2048; // Public Exponent\n\nvar PUBLIC_EXPONENT = new Uint8Array([0x01, 0x00, 0x01]);\n/**\r\n * This class implements functions used by the browser library to perform cryptography operations such as\r\n * hashing and encoding. It also has helper functions to validate the availability of specific APIs.\r\n */\n\nvar BrowserCrypto =\n/** @class */\nfunction () {\n  function BrowserCrypto(logger) {\n    this.logger = logger;\n\n    if (!this.hasCryptoAPI()) {\n      throw BrowserAuthError.createCryptoNotAvailableError(\"Browser crypto or msCrypto object not available.\");\n    }\n\n    this._keygenAlgorithmOptions = {\n      name: PKCS1_V15_KEYGEN_ALG,\n      hash: S256_HASH_ALG,\n      modulusLength: MODULUS_LENGTH,\n      publicExponent: PUBLIC_EXPONENT\n    };\n  }\n  /**\r\n   * Returns a sha-256 hash of the given dataString as an ArrayBuffer.\r\n   * @param dataString\r\n   */\n\n\n  BrowserCrypto.prototype.sha256Digest = function (dataString) {\n    return __awaiter(this, void 0, void 0, function () {\n      var data;\n      return __generator(this, function (_a) {\n        data = BrowserStringUtils.stringToUtf8Arr(dataString);\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.getMSCryptoDigest(S256_HASH_ALG, data) : this.getSubtleCryptoDigest(S256_HASH_ALG, data)];\n      });\n    });\n  };\n  /**\r\n   * Populates buffer with cryptographically random values.\r\n   * @param dataBuffer\r\n   */\n\n\n  BrowserCrypto.prototype.getRandomValues = function (dataBuffer) {\n    var cryptoObj = window[\"msCrypto\"] || window.crypto;\n\n    if (!cryptoObj.getRandomValues) {\n      throw BrowserAuthError.createCryptoNotAvailableError(\"getRandomValues does not exist.\");\n    }\n\n    cryptoObj.getRandomValues(dataBuffer);\n  };\n  /**\r\n   * Generates a keypair based on current keygen algorithm config.\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.generateKeyPair = function (extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.msCryptoGenerateKey(extractable, usages) : window.crypto.subtle.generateKey(this._keygenAlgorithmOptions, extractable, usages)];\n      });\n    });\n  };\n  /**\r\n   * Export key as Json Web Key (JWK)\r\n   * @param key\r\n   * @param format\r\n   */\n\n\n  BrowserCrypto.prototype.exportJwk = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.msCryptoExportJwk(key) : window.crypto.subtle.exportKey(KEY_FORMAT_JWK, key)];\n      });\n    });\n  };\n  /**\r\n   * Imports key as Json Web Key (JWK), can set extractable and usages.\r\n   * @param key\r\n   * @param format\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.importJwk = function (key, extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var keyString, keyBuffer;\n      return __generator(this, function (_a) {\n        keyString = BrowserCrypto.getJwkString(key);\n        keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.msCryptoImportKey(keyBuffer, extractable, usages) : window.crypto.subtle.importKey(KEY_FORMAT_JWK, key, this._keygenAlgorithmOptions, extractable, usages)];\n      });\n    });\n  };\n  /**\r\n   * Signs given data with given key\r\n   * @param key\r\n   * @param data\r\n   */\n\n\n  BrowserCrypto.prototype.sign = function (key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.msCryptoSign(key, data) : window.crypto.subtle.sign(this._keygenAlgorithmOptions, key, data)];\n      });\n    });\n  };\n  /**\r\n   * Check whether IE crypto or other browser cryptography is available.\r\n   */\n\n\n  BrowserCrypto.prototype.hasCryptoAPI = function () {\n    return this.hasIECrypto() || this.hasBrowserCrypto();\n  };\n  /**\r\n   * Checks whether IE crypto (AKA msCrypto) is available.\r\n   */\n\n\n  BrowserCrypto.prototype.hasIECrypto = function () {\n    return \"msCrypto\" in window;\n  };\n  /**\r\n   * Check whether browser crypto is available.\r\n   */\n\n\n  BrowserCrypto.prototype.hasBrowserCrypto = function () {\n    return \"crypto\" in window;\n  };\n  /**\r\n   * Helper function for SHA digest.\r\n   * @param algorithm\r\n   * @param data\r\n   */\n\n\n  BrowserCrypto.prototype.getSubtleCryptoDigest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , window.crypto.subtle.digest(algorithm, data)];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for SHA digest.\r\n   * @param algorithm\r\n   * @param data\r\n   */\n\n\n  BrowserCrypto.prototype.getMSCryptoDigest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\n          digestOperation.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          digestOperation.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for generating a keypair\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.msCryptoGenerateKey = function (extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msGenerateKey = window[\"msCrypto\"].subtle.generateKey(_this._keygenAlgorithmOptions, extractable, usages);\n          msGenerateKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msGenerateKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for exportKey\r\n   * @param key\r\n   * @param format\r\n   */\n\n\n  BrowserCrypto.prototype.msCryptoExportJwk = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\n          msExportKey.addEventListener(\"complete\", function (e) {\n            var resultBuffer = e.target.result;\n            var resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer)).replace(/\\r/g, \"\").replace(/\\n/g, \"\").replace(/\\t/g, \"\").split(\" \").join(\"\").replace(\"\\0\", \"\");\n\n            try {\n              resolve(JSON.parse(resultString));\n            } catch (e) {\n              reject(e);\n            }\n          });\n          msExportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for importKey\r\n   * @param key\r\n   * @param format\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.msCryptoImportKey = function (keyBuffer, extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, _this._keygenAlgorithmOptions, extractable, usages);\n          msImportKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msImportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for sign JWT\r\n   * @param key\r\n   * @param data\r\n   */\n\n\n  BrowserCrypto.prototype.msCryptoSign = function (key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msSign = window[\"msCrypto\"].subtle.sign(_this._keygenAlgorithmOptions, key, data);\n          msSign.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msSign.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * Returns stringified jwk.\r\n   * @param jwk\r\n   */\n\n\n  BrowserCrypto.getJwkString = function (jwk) {\n    return JSON.stringify(jwk, Object.keys(jwk).sort());\n  };\n\n  return BrowserCrypto;\n}();\n\nexport { BrowserCrypto };","map":{"version":3,"mappings":"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","names":["PKCS1_V15_KEYGEN_ALG","S256_HASH_ALG","MODULUS_LENGTH","PUBLIC_EXPONENT","Uint8Array","logger","hasCryptoAPI","BrowserAuthError","createCryptoNotAvailableError","_keygenAlgorithmOptions","name","hash","modulusLength","publicExponent","BrowserCrypto","dataString","data","BrowserStringUtils","stringToUtf8Arr","hasIECrypto","getMSCryptoDigest","getSubtleCryptoDigest","dataBuffer","cryptoObj","window","crypto","getRandomValues","extractable","usages","msCryptoGenerateKey","subtle","generateKey","key","msCryptoExportJwk","exportKey","KEY_FORMAT_JWK","keyString","getJwkString","keyBuffer","stringToArrayBuffer","msCryptoImportKey","importKey","msCryptoSign","sign","hasBrowserCrypto","algorithm","digest","Promise","resolve","reject","digestOperation","buffer","addEventListener","e","target","result","error","msGenerateKey","_this","msExportKey","resultBuffer","resultString","utf8ArrToString","replace","split","join","JSON","parse","msImportKey","msSign","jwk","stringify","Object","keys","sort"],"sources":["C:\\Users\\empti\\OneDrive\\Desktop\\User_Interface\\user_interface_frontend\\node_modules\\@azure\\msal-browser\\src\\crypto\\BrowserCrypto.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { BrowserStringUtils } from \"../utils/BrowserStringUtils\";\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\nimport { KEY_FORMAT_JWK } from \"../utils/BrowserConstants\";\nimport { Logger } from \"..\";\n/**\n * See here for more info on RsaHashedKeyGenParams: https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams\n */\n// RSA KeyGen Algorithm\nconst PKCS1_V15_KEYGEN_ALG = \"RSASSA-PKCS1-v1_5\";\n// SHA-256 hashing algorithm\nconst S256_HASH_ALG = \"SHA-256\";\n// MOD length for PoP tokens\nconst MODULUS_LENGTH = 2048;\n// Public Exponent\nconst PUBLIC_EXPONENT: Uint8Array = new Uint8Array([0x01, 0x00, 0x01]);\n\n/**\n * This class implements functions used by the browser library to perform cryptography operations such as\n * hashing and encoding. It also has helper functions to validate the availability of specific APIs.\n */\nexport class BrowserCrypto {\n\n    private _keygenAlgorithmOptions: RsaHashedKeyGenParams;\n    private logger: Logger;\n\n    constructor(logger: Logger) {\n        this.logger = logger;\n        \n        if (!(this.hasCryptoAPI())) {\n            throw BrowserAuthError.createCryptoNotAvailableError(\"Browser crypto or msCrypto object not available.\");\n        }\n\n        this._keygenAlgorithmOptions = {\n            name: PKCS1_V15_KEYGEN_ALG,\n            hash: S256_HASH_ALG,\n            modulusLength: MODULUS_LENGTH,\n            publicExponent: PUBLIC_EXPONENT\n        };\n    }\n\n    /**\n     * Returns a sha-256 hash of the given dataString as an ArrayBuffer.\n     * @param dataString \n     */\n    async sha256Digest(dataString: string): Promise<ArrayBuffer> {\n        const data = BrowserStringUtils.stringToUtf8Arr(dataString);\n\n        return this.hasIECrypto() ? this.getMSCryptoDigest(S256_HASH_ALG, data) : this.getSubtleCryptoDigest(S256_HASH_ALG, data);\n    }\n\n    /**\n     * Populates buffer with cryptographically random values.\n     * @param dataBuffer \n     */\n    getRandomValues(dataBuffer: Uint8Array): void {\n        const cryptoObj = window[\"msCrypto\"] || window.crypto;\n        if (!cryptoObj.getRandomValues) {\n            throw BrowserAuthError.createCryptoNotAvailableError(\"getRandomValues does not exist.\");\n        }\n        cryptoObj.getRandomValues(dataBuffer);\n    }\n\n    /**\n     * Generates a keypair based on current keygen algorithm config.\n     * @param extractable \n     * @param usages \n     */\n    async generateKeyPair(extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKeyPair> {\n        return (\n            this.hasIECrypto() ? \n                this.msCryptoGenerateKey(extractable, usages) \n                : window.crypto.subtle.generateKey(this._keygenAlgorithmOptions, extractable, usages)\n        ) as Promise<CryptoKeyPair>;\n    }\n\n    /**\n     * Export key as Json Web Key (JWK)\n     * @param key \n     * @param format \n     */\n    async exportJwk(key: CryptoKey): Promise<JsonWebKey> {\n        return this.hasIECrypto() ? this.msCryptoExportJwk(key) : window.crypto.subtle.exportKey(KEY_FORMAT_JWK, key);\n    }\n\n    /**\n     * Imports key as Json Web Key (JWK), can set extractable and usages.\n     * @param key \n     * @param format \n     * @param extractable \n     * @param usages \n     */\n    async importJwk(key: JsonWebKey, extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKey> {\n        const keyString = BrowserCrypto.getJwkString(key);\n        const keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\n\n        return this.hasIECrypto() ? \n            this.msCryptoImportKey(keyBuffer, extractable, usages) \n            : window.crypto.subtle.importKey(KEY_FORMAT_JWK, key, this._keygenAlgorithmOptions, extractable, usages);\n    }\n\n    /**\n     * Signs given data with given key\n     * @param key \n     * @param data \n     */\n    async sign(key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\n        return this.hasIECrypto() ?\n            this.msCryptoSign(key, data)\n            : window.crypto.subtle.sign(this._keygenAlgorithmOptions, key, data);\n    }\n\n    /**\n     * Check whether IE crypto or other browser cryptography is available.\n     */\n    private hasCryptoAPI(): boolean {\n        return this.hasIECrypto() || this.hasBrowserCrypto();\n    }\n\n    /**\n     * Checks whether IE crypto (AKA msCrypto) is available.\n     */\n    private hasIECrypto(): boolean {\n        return \"msCrypto\" in window;\n    }\n\n    /**\n     * Check whether browser crypto is available.\n     */\n    private hasBrowserCrypto(): boolean {\n        return \"crypto\" in window;\n    }\n\n    /**\n     * Helper function for SHA digest.\n     * @param algorithm \n     * @param data \n     */\n    private async getSubtleCryptoDigest(algorithm: string, data: Uint8Array): Promise<ArrayBuffer> {\n        return window.crypto.subtle.digest(algorithm, data);\n    }\n\n    /**\n     * IE Helper function for SHA digest.\n     * @param algorithm \n     * @param data \n     */\n    private async getMSCryptoDigest(algorithm: string, data: Uint8Array): Promise<ArrayBuffer> {\n        return new Promise((resolve, reject) => {\n            const digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\n            digestOperation.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\n                resolve(e.target.result);\n            });\n            digestOperation.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * IE Helper function for generating a keypair\n     * @param extractable \n     * @param usages \n     */\n    private async msCryptoGenerateKey(extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKeyPair> {\n        return new Promise((resolve: Function, reject: Function) => {\n            const msGenerateKey = window[\"msCrypto\"].subtle.generateKey(this._keygenAlgorithmOptions, extractable, usages);\n            msGenerateKey.addEventListener(\"complete\", (e: { target: { result: CryptoKeyPair | PromiseLike<CryptoKeyPair>; }; }) => {\n                resolve(e.target.result);\n            });\n\n            msGenerateKey.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * IE Helper function for exportKey\n     * @param key \n     * @param format \n     */\n    private async msCryptoExportJwk(key: CryptoKey): Promise<JsonWebKey> {\n        return new Promise((resolve: Function, reject: Function) => {\n            const msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\n            msExportKey.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer; }; }) => {\n                const resultBuffer: ArrayBuffer = e.target.result;\n\n                const resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer))\n                    .replace(/\\r/g, \"\")\n                    .replace(/\\n/g, \"\")\n                    .replace(/\\t/g, \"\")\n                    .split(\" \").join(\"\")\n                    .replace(\"\\u0000\", \"\");\n\n                try {\n                    resolve(JSON.parse(resultString));\n                } catch (e) {\n                    reject(e);\n                }\n            });\n\n            msExportKey.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * IE Helper function for importKey\n     * @param key \n     * @param format \n     * @param extractable \n     * @param usages \n     */\n    private async msCryptoImportKey(keyBuffer: ArrayBuffer, extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKey> {\n        return new Promise((resolve: Function, reject: Function) => {\n            const msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, this._keygenAlgorithmOptions, extractable, usages);\n            msImportKey.addEventListener(\"complete\", (e: { target: { result: CryptoKey | PromiseLike<CryptoKey>; }; }) => {\n                resolve(e.target.result);\n            });\n\n            msImportKey.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * IE Helper function for sign JWT\n     * @param key \n     * @param data \n     */\n    private async msCryptoSign(key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\n        return new Promise((resolve: Function, reject: Function) => {\n            const msSign = window[\"msCrypto\"].subtle.sign(this._keygenAlgorithmOptions, key, data);\n            msSign.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\n                resolve(e.target.result);\n            });\n\n            msSign.addEventListener(\"error\", (error: string) => {\n                reject(error);\n            });\n        });\n    }\n\n    /**\n     * Returns stringified jwk.\n     * @param jwk \n     */\n    static getJwkString(jwk: JsonWebKey): string {\n        return JSON.stringify(jwk, Object.keys(jwk).sort());\n    }\n}\n"]},"metadata":{},"sourceType":"module"}