{"ast":null,"code":"/*! @azure/msal-common v6.1.0 2022-02-08 */\n'use strict';\n\nimport { __awaiter, __generator, __extends } from '../_virtual/_tslib.js';\nimport { Constants, CredentialType, AuthenticationScheme, CacheSchemaType, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.js';\nimport { CredentialEntity } from './entities/CredentialEntity.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from './entities/AccountEntity.js';\nimport { AuthError } from '../error/AuthError.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { AuthToken } from '../account/AuthToken.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\n\nvar CacheManager =\n/** @class */\nfunction () {\n  function CacheManager(clientId, cryptoImpl) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n  }\n  /**\r\n   * Returns all accounts in cache\r\n   */\n\n\n  CacheManager.prototype.getAllAccounts = function () {\n    var _this = this;\n\n    var currentAccounts = this.getAccountsFilteredBy();\n    var accountValues = Object.keys(currentAccounts).map(function (accountKey) {\n      return currentAccounts[accountKey];\n    });\n    var numAccounts = accountValues.length;\n\n    if (numAccounts < 1) {\n      return [];\n    } else {\n      var allAccounts = accountValues.map(function (value) {\n        var accountEntity = CacheManager.toObject(new AccountEntity(), value);\n        var accountInfo = accountEntity.getAccountInfo();\n\n        var idToken = _this.readIdTokenFromCache(_this.clientId, accountInfo);\n\n        if (idToken && !accountInfo.idTokenClaims) {\n          accountInfo.idTokenClaims = new AuthToken(idToken.secret, _this.cryptoImpl).claims;\n        }\n\n        return accountInfo;\n      });\n      return allAccounts;\n    }\n  };\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord\r\n   */\n\n\n  CacheManager.prototype.saveCacheRecord = function (cacheRecord) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!cacheRecord) {\n              throw ClientAuthError.createNullOrUndefinedCacheRecord();\n            }\n\n            if (!!cacheRecord.account) {\n              this.setAccount(cacheRecord.account);\n            }\n\n            if (!!cacheRecord.idToken) {\n              this.setIdTokenCredential(cacheRecord.idToken);\n            }\n\n            if (!!!cacheRecord.accessToken) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.saveAccessToken(cacheRecord.accessToken)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            if (!!cacheRecord.refreshToken) {\n              this.setRefreshTokenCredential(cacheRecord.refreshToken);\n            }\n\n            if (!!cacheRecord.appMetadata) {\n              this.setAppMetadata(cacheRecord.appMetadata);\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * saves access token credential\r\n   * @param credential\r\n   */\n\n\n  CacheManager.prototype.saveAccessToken = function (credential) {\n    return __awaiter(this, void 0, void 0, function () {\n      var currentTokenCache, currentScopes, currentAccessTokens, removedAccessTokens_1;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            currentTokenCache = this.getCredentialsFilteredBy({\n              clientId: credential.clientId,\n              credentialType: credential.credentialType,\n              environment: credential.environment,\n              homeAccountId: credential.homeAccountId,\n              realm: credential.realm,\n              tokenType: credential.tokenType,\n              requestedClaimsHash: credential.requestedClaimsHash\n            });\n            currentScopes = ScopeSet.fromString(credential.target);\n            currentAccessTokens = Object.keys(currentTokenCache.accessTokens).map(function (key) {\n              return currentTokenCache.accessTokens[key];\n            });\n            if (!currentAccessTokens) return [3\n            /*break*/\n            , 2];\n            removedAccessTokens_1 = [];\n            currentAccessTokens.forEach(function (tokenEntity) {\n              var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n\n              if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n                removedAccessTokens_1.push(_this.removeCredential(tokenEntity));\n              }\n            });\n            return [4\n            /*yield*/\n            , Promise.all(removedAccessTokens_1)];\n\n          case 1:\n            _a.sent();\n\n            _a.label = 2;\n\n          case 2:\n            this.setAccessTokenCredential(credential);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n\n\n  CacheManager.prototype.getAccountsFilteredBy = function (accountFilter) {\n    return this.getAccountsFilteredByInternal(accountFilter ? accountFilter.homeAccountId : \"\", accountFilter ? accountFilter.environment : \"\", accountFilter ? accountFilter.realm : \"\");\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n\n\n  CacheManager.prototype.getAccountsFilteredByInternal = function (homeAccountId, environment, realm) {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    var matchingAccounts = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      var entity = _this.getAccount(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {\n        return;\n      }\n\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n\n      if (!!realm && !_this.matchRealm(entity, realm)) {\n        return;\n      }\n\n      matchingAccounts[cacheKey] = entity;\n    });\n    return matchingAccounts;\n  };\n  /**\r\n   * retrieve credentails matching all provided filters; if no filter is set, get all credentials\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param credentialType\r\n   * @param clientId\r\n   * @param realm\r\n   * @param target\r\n   */\n\n\n  CacheManager.prototype.getCredentialsFilteredBy = function (filter) {\n    return this.getCredentialsFilteredByInternal(filter.homeAccountId, filter.environment, filter.credentialType, filter.clientId, filter.familyId, filter.realm, filter.target, filter.oboAssertion, filter.tokenType, filter.keyId, filter.requestedClaimsHash);\n  };\n  /**\r\n   * Support function to help match credentials\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param credentialType\r\n   * @param clientId\r\n   * @param realm\r\n   * @param target\r\n   * @param oboAssertion\r\n   * @param tokenType\r\n   */\n\n\n  CacheManager.prototype.getCredentialsFilteredByInternal = function (homeAccountId, environment, credentialType, clientId, familyId, realm, target, oboAssertion, tokenType, keyId, requestedClaimsHash) {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    var matchingCredentials = {\n      idTokens: {},\n      accessTokens: {},\n      refreshTokens: {}\n    };\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-credential type cache entities\n      var credType = CredentialEntity.getCredentialType(cacheKey);\n\n      if (credType === Constants.NOT_DEFINED) {\n        return;\n      } // Attempt retrieval\n\n\n      var entity = _this.getSpecificCredential(cacheKey, credType);\n\n      if (!entity) {\n        return;\n      }\n\n      if (!!oboAssertion && !_this.matchOboAssertion(entity, oboAssertion)) {\n        return;\n      }\n\n      if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {\n        return;\n      }\n\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n\n      if (!!realm && !_this.matchRealm(entity, realm)) {\n        return;\n      }\n\n      if (!!credentialType && !_this.matchCredentialType(entity, credentialType)) {\n        return;\n      }\n\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n\n      if (!!familyId && !_this.matchFamilyId(entity, familyId)) {\n        return;\n      }\n      /*\r\n       * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n       * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n       */\n\n\n      if (!!target && !_this.matchTarget(entity, target)) {\n        return;\n      } // If request OR cached entity has requested Claims Hash, check if they match\n\n\n      if (requestedClaimsHash || entity.requestedClaimsHash) {\n        // Don't match if either is undefined or they are different\n        if (entity.requestedClaimsHash !== requestedClaimsHash) {\n          return;\n        }\n      } // Access Token with Auth Scheme specific matching\n\n\n      if (credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n        if (!!tokenType && !_this.matchTokenType(entity, tokenType)) {\n          return;\n        } // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n\n\n        if (tokenType === AuthenticationScheme.SSH) {\n          if (keyId && !_this.matchKeyId(entity, keyId)) {\n            return;\n          }\n        }\n      } // At this point, the entity matches the request, update cache key if key schema has changed\n\n\n      var updatedCacheKey = _this.updateCredentialCacheKey(cacheKey, entity);\n\n      switch (credType) {\n        case CredentialType.ID_TOKEN:\n          matchingCredentials.idTokens[updatedCacheKey] = entity;\n          break;\n\n        case CredentialType.ACCESS_TOKEN:\n        case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n          matchingCredentials.accessTokens[updatedCacheKey] = entity;\n          break;\n\n        case CredentialType.REFRESH_TOKEN:\n          matchingCredentials.refreshTokens[updatedCacheKey] = entity;\n          break;\n      }\n    });\n    return matchingCredentials;\n  };\n  /**\r\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n   * @param filter\r\n   */\n\n\n  CacheManager.prototype.getAppMetadataFilteredBy = function (filter) {\n    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n  };\n  /**\r\n   * Support function to help match appMetadata\r\n   * @param environment\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.getAppMetadataFilteredByInternal = function (environment, clientId) {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    var matchingAppMetadata = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-appMetadata type cache entities\n      if (!_this.isAppMetadata(cacheKey)) {\n        return;\n      } // Attempt retrieval\n\n\n      var entity = _this.getAppMetadata(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  };\n  /**\r\n   * retrieve authorityMetadata that contains a matching alias\r\n   * @param filter\r\n   */\n\n\n  CacheManager.prototype.getAuthorityMetadataByAlias = function (host) {\n    var _this = this;\n\n    var allCacheKeys = this.getAuthorityMetadataKeys();\n    var matchedEntity = null;\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {\n        return;\n      } // Attempt retrieval\n\n\n      var entity = _this.getAuthorityMetadata(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  };\n  /**\r\n   * Removes all accounts and related tokens from cache.\r\n   */\n\n\n  CacheManager.prototype.removeAllAccounts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var allCacheKeys, removedAccounts;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allCacheKeys = this.getKeys();\n            removedAccounts = [];\n            allCacheKeys.forEach(function (cacheKey) {\n              var entity = _this.getAccount(cacheKey);\n\n              if (!entity) {\n                return;\n              }\n\n              removedAccounts.push(_this.removeAccount(cacheKey));\n            });\n            return [4\n            /*yield*/\n            , Promise.all(removedAccounts)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , true];\n        }\n      });\n    });\n  };\n  /**\r\n   * returns a boolean if the given account is removed\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.removeAccount = function (accountKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      var account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            account = this.getAccount(accountKey);\n\n            if (!account) {\n              throw ClientAuthError.createNoAccountFoundError();\n            }\n\n            return [4\n            /*yield*/\n            , this.removeAccountContext(account)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent() && this.removeItem(accountKey, CacheSchemaType.ACCOUNT)];\n        }\n      });\n    });\n  };\n  /**\r\n   * returns a boolean if the given account is removed\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.removeAccountContext = function (account) {\n    return __awaiter(this, void 0, void 0, function () {\n      var allCacheKeys, accountId, removedCredentials;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allCacheKeys = this.getKeys();\n            accountId = account.generateAccountId();\n            removedCredentials = [];\n            allCacheKeys.forEach(function (cacheKey) {\n              // don't parse any non-credential type cache entities\n              var credType = CredentialEntity.getCredentialType(cacheKey);\n\n              if (credType === Constants.NOT_DEFINED) {\n                return;\n              }\n\n              var cacheEntity = _this.getSpecificCredential(cacheKey, credType);\n\n              if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {\n                removedCredentials.push(_this.removeCredential(cacheEntity));\n              }\n            });\n            return [4\n            /*yield*/\n            , Promise.all(removedCredentials)];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , true];\n        }\n      });\n    });\n  };\n  /**\r\n   * returns a boolean if the given credential is removed\r\n   * @param credential\r\n   */\n\n\n  CacheManager.prototype.removeCredential = function (credential) {\n    return __awaiter(this, void 0, void 0, function () {\n      var key, accessTokenWithAuthSchemeEntity, kid;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            key = credential.generateCredentialKey();\n            if (!(credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase())) return [3\n            /*break*/\n            , 4];\n            if (!(credential.tokenType === AuthenticationScheme.POP)) return [3\n            /*break*/\n            , 4];\n            accessTokenWithAuthSchemeEntity = credential;\n            kid = accessTokenWithAuthSchemeEntity.keyId;\n            if (!kid) return [3\n            /*break*/\n            , 4];\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.cryptoImpl.removeTokenBindingKey(kid)];\n\n          case 2:\n            _a.sent();\n\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            _a.sent();\n\n            throw ClientAuthError.createBindingKeyNotRemovedError();\n\n          case 4:\n            return [2\n            /*return*/\n            , this.removeItem(key, CacheSchemaType.CREDENTIAL)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes all app metadata objects from cache.\r\n   */\n\n\n  CacheManager.prototype.removeAppMetadata = function () {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(function (cacheKey) {\n      if (_this.isAppMetadata(cacheKey)) {\n        _this.removeItem(cacheKey, CacheSchemaType.APP_METADATA);\n      }\n    });\n    return true;\n  };\n  /**\r\n   * Retrieve the cached credentials into a cacherecord\r\n   * @param account\r\n   * @param clientId\r\n   * @param scopes\r\n   * @param environment\r\n   * @param authScheme\r\n   */\n\n\n  CacheManager.prototype.readCacheRecord = function (account, clientId, request, environment) {\n    var cachedAccount = this.readAccountFromCache(account);\n    var cachedIdToken = this.readIdTokenFromCache(clientId, account);\n    var cachedAccessToken = this.readAccessTokenFromCache(clientId, account, request);\n    var cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);\n    var cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);\n\n    if (cachedAccount && cachedIdToken) {\n      cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\n    }\n\n    return {\n      account: cachedAccount,\n      idToken: cachedIdToken,\n      accessToken: cachedAccessToken,\n      refreshToken: cachedRefreshToken,\n      appMetadata: cachedAppMetadata\n    };\n  };\n  /**\r\n   * Retrieve AccountEntity from cache\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.readAccountFromCache = function (account) {\n    var accountKey = AccountEntity.generateAccountCacheKey(account);\n    return this.getAccount(accountKey);\n  };\n  /**\r\n   * Retrieve IdTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param inputRealm\r\n   */\n\n\n  CacheManager.prototype.readIdTokenFromCache = function (clientId, account) {\n    var idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: clientId,\n      realm: account.tenantId\n    };\n    var credentialCache = this.getCredentialsFilteredBy(idTokenFilter);\n    var idTokens = Object.keys(credentialCache.idTokens).map(function (key) {\n      return credentialCache.idTokens[key];\n    });\n    var numIdTokens = idTokens.length;\n\n    if (numIdTokens < 1) {\n      return null;\n    } else if (numIdTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n\n    return idTokens[0];\n  };\n  /**\r\n   * Retrieve AccessTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param scopes\r\n   * @param authScheme\r\n   */\n\n\n  CacheManager.prototype.readAccessTokenFromCache = function (clientId, account, request) {\n    var scopes = new ScopeSet(request.scopes || []);\n    var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\r\n     * Distinguish between Bearer and PoP/SSH token cache types\r\n     * Cast to lowercase to handle \"bearer\" from ADFS\r\n     */\n\n    var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    var accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: clientId,\n      realm: account.tenantId,\n      target: scopes.printScopesLowerCase(),\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash\n    };\n    var credentialCache = this.getCredentialsFilteredBy(accessTokenFilter);\n    var accessTokens = Object.keys(credentialCache.accessTokens).map(function (key) {\n      return credentialCache.accessTokens[key];\n    });\n    var numAccessTokens = accessTokens.length;\n\n    if (numAccessTokens < 1) {\n      return null;\n    } else if (numAccessTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n\n    return accessTokens[0];\n  };\n  /**\r\n   * Helper to retrieve the appropriate refresh token from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param familyRT\r\n   */\n\n\n  CacheManager.prototype.readRefreshTokenFromCache = function (clientId, account, familyRT) {\n    var id = familyRT ? THE_FAMILY_ID : undefined;\n    var refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: clientId,\n      familyId: id\n    };\n    var credentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);\n    var refreshTokens = Object.keys(credentialCache.refreshTokens).map(function (key) {\n      return credentialCache.refreshTokens[key];\n    });\n    var numRefreshTokens = refreshTokens.length;\n\n    if (numRefreshTokens < 1) {\n      return null;\n    } // address the else case after remove functions address environment aliases\n\n\n    return refreshTokens[0];\n  };\n  /**\r\n   * Retrieve AppMetadataEntity from cache\r\n   */\n\n\n  CacheManager.prototype.readAppMetadataFromCache = function (environment, clientId) {\n    var appMetadataFilter = {\n      environment: environment,\n      clientId: clientId\n    };\n    var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    var appMetadataEntries = Object.keys(appMetadata).map(function (key) {\n      return appMetadata[key];\n    });\n    var numAppMetadata = appMetadataEntries.length;\n\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\n    }\n\n    return appMetadataEntries[0];\n  };\n  /**\r\n   * Return the family_id value associated  with FOCI\r\n   * @param environment\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.isAppMetadataFOCI = function (environment, clientId) {\n    var appMetadata = this.readAppMetadataFromCache(environment, clientId);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  };\n  /**\r\n   * helper to match account ids\r\n   * @param value\r\n   * @param homeAccountId\r\n   */\n\n\n  CacheManager.prototype.matchHomeAccountId = function (entity, homeAccountId) {\n    return !!(entity.homeAccountId && homeAccountId === entity.homeAccountId);\n  };\n  /**\r\n   * helper to match assertion\r\n   * @param value\r\n   * @param oboAssertion\r\n   */\n\n\n  CacheManager.prototype.matchOboAssertion = function (entity, oboAssertion) {\n    return !!(entity.oboAssertion && oboAssertion === entity.oboAssertion);\n  };\n  /**\r\n   * helper to match environment\r\n   * @param value\r\n   * @param environment\r\n   */\n\n\n  CacheManager.prototype.matchEnvironment = function (entity, environment) {\n    var cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * helper to match credential type\r\n   * @param entity\r\n   * @param credentialType\r\n   */\n\n\n  CacheManager.prototype.matchCredentialType = function (entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  };\n  /**\r\n   * helper to match client ids\r\n   * @param entity\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.matchClientId = function (entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  };\n  /**\r\n   * helper to match family ids\r\n   * @param entity\r\n   * @param familyId\r\n   */\n\n\n  CacheManager.prototype.matchFamilyId = function (entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  };\n  /**\r\n   * helper to match realm\r\n   * @param entity\r\n   * @param realm\r\n   */\n\n\n  CacheManager.prototype.matchRealm = function (entity, realm) {\n    return !!(entity.realm && realm === entity.realm);\n  };\n  /**\r\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n   * @param entity\r\n   * @param target\r\n   */\n\n\n  CacheManager.prototype.matchTarget = function (entity, target) {\n    var isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n\n    var entityScopeSet = ScopeSet.fromString(entity.target);\n    var requestTargetScopeSet = ScopeSet.fromString(target);\n\n    if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {\n      requestTargetScopeSet.removeOIDCScopes(); // ignore OIDC scopes\n    } else {\n      requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);\n    }\n\n    return entityScopeSet.containsScopeSet(requestTargetScopeSet);\n  };\n  /**\r\n   * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n\n\n  CacheManager.prototype.matchTokenType = function (entity, tokenType) {\n    return !!(entity.tokenType && entity.tokenType === tokenType);\n  };\n  /**\r\n   * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n\n\n  CacheManager.prototype.matchKeyId = function (entity, keyId) {\n    return !!(entity.keyId && entity.keyId === keyId);\n  };\n  /**\r\n   * returns if a given cache entity is of the type appmetadata\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.isAppMetadata = function (key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  };\n  /**\r\n   * returns if a given cache entity is of the type authoritymetadata\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.isAuthorityMetadata = function (key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  };\n  /**\r\n   * returns cache key used for cloud instance metadata\r\n   */\n\n\n  CacheManager.prototype.generateAuthorityMetadataCacheKey = function (authority) {\n    return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + \"-\" + this.clientId + \"-\" + authority;\n  };\n  /**\r\n   * Returns the specific credential (IdToken/AccessToken/RefreshToken) from the cache\r\n   * @param key\r\n   * @param credType\r\n   */\n\n\n  CacheManager.prototype.getSpecificCredential = function (key, credType) {\n    switch (credType) {\n      case CredentialType.ID_TOKEN:\n        {\n          return this.getIdTokenCredential(key);\n        }\n\n      case CredentialType.ACCESS_TOKEN:\n      case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n        {\n          return this.getAccessTokenCredential(key);\n        }\n\n      case CredentialType.REFRESH_TOKEN:\n        {\n          return this.getRefreshTokenCredential(key);\n        }\n\n      default:\n        return null;\n    }\n  };\n  /**\r\n   * Helper to convert serialized data to object\r\n   * @param obj\r\n   * @param json\r\n   */\n\n\n  CacheManager.toObject = function (obj, json) {\n    for (var propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n\n    return obj;\n  };\n\n  return CacheManager;\n}();\n\nvar DefaultStorageClass =\n/** @class */\nfunction (_super) {\n  __extends(DefaultStorageClass, _super);\n\n  function DefaultStorageClass() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DefaultStorageClass.prototype.setAccount = function () {\n    var notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAccount = function () {\n    var notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAppMetadata = function () {\n    var notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAppMetadata = function () {\n    var notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setServerTelemetry = function () {\n    var notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getServerTelemetry = function () {\n    var notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAuthorityMetadataKeys = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setThrottlingCache = function () {\n    var notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getThrottlingCache = function () {\n    var notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.removeItem = function () {\n    var notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.containsKey = function () {\n    var notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getKeys = function () {\n    var notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var notImplErr;\n      return __generator(this, function (_a) {\n        notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n      });\n    });\n  };\n\n  DefaultStorageClass.prototype.updateCredentialCacheKey = function () {\n    var notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n\n  return DefaultStorageClass;\n}(CacheManager);\n\nexport { CacheManager, DefaultStorageClass };","map":{"version":3,"mappings":"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","names":["clientId","cryptoImpl","CacheManager","currentAccounts","getAccountsFilteredBy","accountValues","Object","keys","map","accountKey","numAccounts","length","allAccounts","value","accountEntity","toObject","AccountEntity","accountInfo","getAccountInfo","idToken","_this","readIdTokenFromCache","idTokenClaims","AuthToken","secret","claims","cacheRecord","ClientAuthError","createNullOrUndefinedCacheRecord","account","setAccount","setIdTokenCredential","accessToken","saveAccessToken","_a","refreshToken","setRefreshTokenCredential","appMetadata","setAppMetadata","credential","currentTokenCache","getCredentialsFilteredBy","credentialType","environment","homeAccountId","realm","tokenType","requestedClaimsHash","currentScopes","ScopeSet","fromString","target","currentAccessTokens","accessTokens","key","removedAccessTokens_1","forEach","tokenEntity","tokenScopeSet","intersectingScopeSets","push","removeCredential","Promise","all","setAccessTokenCredential","accountFilter","getAccountsFilteredByInternal","allCacheKeys","getKeys","matchingAccounts","cacheKey","entity","getAccount","matchHomeAccountId","matchEnvironment","matchRealm","filter","getCredentialsFilteredByInternal","familyId","oboAssertion","keyId","matchingCredentials","idTokens","refreshTokens","credType","CredentialEntity","getCredentialType","Constants","NOT_DEFINED","getSpecificCredential","matchOboAssertion","matchCredentialType","matchClientId","matchFamilyId","matchTarget","CredentialType","ACCESS_TOKEN_WITH_AUTH_SCHEME","matchTokenType","AuthenticationScheme","SSH","matchKeyId","updatedCacheKey","updateCredentialCacheKey","ID_TOKEN","ACCESS_TOKEN","REFRESH_TOKEN","getAppMetadataFilteredByInternal","matchingAppMetadata","isAppMetadata","getAppMetadata","host","getAuthorityMetadataKeys","matchedEntity","isAuthorityMetadata","indexOf","getAuthorityMetadata","aliases","removedAccounts","removeAccount","createNoAccountFoundError","removeAccountContext","removeItem","CacheSchemaType","ACCOUNT","accountId","generateAccountId","removedCredentials","cacheEntity","generateCredentialKey","toLowerCase","POP","accessTokenWithAuthSchemeEntity","kid","removeTokenBindingKey","createBindingKeyNotRemovedError","CREDENTIAL","APP_METADATA","request","cachedAccount","readAccountFromCache","cachedIdToken","cachedAccessToken","readAccessTokenFromCache","cachedRefreshToken","readRefreshTokenFromCache","cachedAppMetadata","readAppMetadataFromCache","generateAccountCacheKey","idTokenFilter","tenantId","credentialCache","numIdTokens","createMultipleMatchingTokensInCacheError","scopes","authScheme","authenticationScheme","BEARER","accessTokenFilter","printScopesLowerCase","sshKid","numAccessTokens","familyRT","id","THE_FAMILY_ID","undefined","refreshTokenFilter","numRefreshTokens","appMetadataFilter","getAppMetadataFilteredBy","appMetadataEntries","numAppMetadata","createMultipleMatchingAppMetadataInCacheError","cloudMetadata","getAuthorityMetadataByAlias","isNotAccessTokenCredential","entityScopeSet","requestTargetScopeSet","containsOnlyOIDCScopes","removeOIDCScopes","removeScope","OFFLINE_ACCESS_SCOPE","containsScopeSet","AUTHORITY_METADATA_CONSTANTS","CACHE_KEY","authority","getIdTokenCredential","getAccessTokenCredential","getRefreshTokenCredential","obj","json","propertyName","__extends","DefaultStorageClass","notImplErr","AuthError","createUnexpectedError"],"sources":["C:\\Users\\empti\\OneDrive\\Desktop\\User_Interface\\user_interface_frontend\\node_modules\\@azure\\msal-common\\src\\cache\\CacheManager.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { AccountCache, AccountFilter, CredentialFilter, CredentialCache, ValidCredentialType, AppMetadataFilter, AppMetadataCache } from \"./utils/CacheTypes\";\nimport { CacheRecord } from \"./entities/CacheRecord\";\nimport { CacheSchemaType, CredentialType, Constants, APP_METADATA, THE_FAMILY_ID, AUTHORITY_METADATA_CONSTANTS, AuthenticationScheme } from \"../utils/Constants\";\nimport { CredentialEntity } from \"./entities/CredentialEntity\";\nimport { ScopeSet } from \"../request/ScopeSet\";\nimport { AccountEntity } from \"./entities/AccountEntity\";\nimport { AccessTokenEntity } from \"./entities/AccessTokenEntity\";\nimport { IdTokenEntity } from \"./entities/IdTokenEntity\";\nimport { RefreshTokenEntity } from \"./entities/RefreshTokenEntity\";\nimport { AuthError } from \"../error/AuthError\";\nimport { ICacheManager } from \"./interface/ICacheManager\";\nimport { ClientAuthError } from \"../error/ClientAuthError\";\nimport { AccountInfo } from \"../account/AccountInfo\";\nimport { AppMetadataEntity } from \"./entities/AppMetadataEntity\";\nimport { ServerTelemetryEntity } from \"./entities/ServerTelemetryEntity\";\nimport { ThrottlingEntity } from \"./entities/ThrottlingEntity\";\nimport { AuthToken } from \"../account/AuthToken\";\nimport { ICrypto } from \"../crypto/ICrypto\";\nimport { AuthorityMetadataEntity } from \"./entities/AuthorityMetadataEntity\";\nimport { BaseAuthRequest } from \"../request/BaseAuthRequest\";\n\n/**\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\n */\nexport abstract class CacheManager implements ICacheManager {\n    protected clientId: string;\n    protected cryptoImpl: ICrypto;\n\n    constructor(clientId: string, cryptoImpl: ICrypto) {\n        this.clientId = clientId;\n        this.cryptoImpl = cryptoImpl;\n    }\n\n    /**\n     * fetch the account entity from the platform cache\n     *  @param accountKey\n     */\n    abstract getAccount(accountKey: string): AccountEntity | null;\n\n    /**\n     * set account entity in the platform cache\n     * @param account\n     */\n    abstract setAccount(account: AccountEntity): void;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param idTokenKey\n     */\n    abstract getIdTokenCredential(idTokenKey: string): IdTokenEntity | null;\n\n    /**\n     * set idToken entity to the platform cache\n     * @param idToken\n     */\n    abstract setIdTokenCredential(idToken: IdTokenEntity): void;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param accessTokenKey\n     */\n    abstract getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null;\n\n    /**\n     * set idToken entity to the platform cache\n     * @param accessToken\n     */\n    abstract setAccessTokenCredential(accessToken: AccessTokenEntity): void;\n\n    /**\n     * fetch the idToken entity from the platform cache\n     * @param refreshTokenKey\n     */\n    abstract getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null;\n\n    /**\n     * set idToken entity to the platform cache\n     * @param refreshToken\n     */\n    abstract setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void;\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey\n     */\n    abstract getAppMetadata(appMetadataKey: string): AppMetadataEntity | null;\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata\n     */\n    abstract setAppMetadata(appMetadata: AppMetadataEntity): void;\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetryKey\n     */\n    abstract getServerTelemetry(serverTelemetryKey: string): ServerTelemetryEntity | null;\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey\n     * @param serverTelemetry\n     */\n    abstract setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void;\n\n    /**\n     * fetch cloud discovery metadata entity from the platform cache\n     * @param key\n     */\n    abstract getAuthorityMetadata(key: string): AuthorityMetadataEntity | null;\n\n    /**\n     * \n     */\n    abstract getAuthorityMetadataKeys(): Array<string>;\n\n    /**\n     * set cloud discovery metadata entity to the platform cache\n     * @param key\n     * @param value\n     */\n    abstract setAuthorityMetadata(key: string, value: AuthorityMetadataEntity): void;\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey\n     */\n    abstract getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null;\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey\n     * @param throttlingCache\n     */\n    abstract setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void;;\n\n    /**\n     * Function to remove an item from cache given its key.\n     * @param key\n     */\n    abstract removeItem(key: string, type?: string): boolean;\n\n    /**\n     * Function which returns boolean whether cache contains a specific key.\n     * @param key\n     */\n    abstract containsKey(key: string, type?: string): boolean;\n\n    /**\n     * Function which retrieves all current keys from the cache.\n     */\n    abstract getKeys(): string[];\n\n    /**\n     * Function which clears cache.\n     */\n    abstract clear(): Promise<void>;\n\n    /**\n     * Function which updates an outdated credential cache key\n     */\n    abstract updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string;\n\n    /**\n     * Returns all accounts in cache\n     */\n    getAllAccounts(): AccountInfo[] {\n        const currentAccounts: AccountCache = this.getAccountsFilteredBy();\n        const accountValues: AccountEntity[] = Object.keys(currentAccounts).map(accountKey => currentAccounts[accountKey]);\n        const numAccounts = accountValues.length;\n        if (numAccounts < 1) {\n            return [];\n        } else {\n            const allAccounts = accountValues.map<AccountInfo>((value) => {\n                const accountEntity = CacheManager.toObject<AccountEntity>(new AccountEntity(), value);\n                const accountInfo = accountEntity.getAccountInfo();\n                const idToken = this.readIdTokenFromCache(this.clientId, accountInfo);\n                if (idToken && !accountInfo.idTokenClaims) {\n                    accountInfo.idTokenClaims = new AuthToken(idToken.secret, this.cryptoImpl).claims;\n                }\n\n                return accountInfo;\n                \n            });\n            return allAccounts;\n        }\n    }\n\n    /**\n     * saves a cache record\n     * @param cacheRecord\n     */\n    async saveCacheRecord(cacheRecord: CacheRecord): Promise<void> {\n        if (!cacheRecord) {\n            throw ClientAuthError.createNullOrUndefinedCacheRecord();\n        }\n\n        if (!!cacheRecord.account) {\n            this.setAccount(cacheRecord.account);\n        }\n\n        if (!!cacheRecord.idToken) {\n            this.setIdTokenCredential(cacheRecord.idToken);\n        }\n\n        if (!!cacheRecord.accessToken) {\n            await this.saveAccessToken(cacheRecord.accessToken);\n        }\n\n        if (!!cacheRecord.refreshToken) {\n            this.setRefreshTokenCredential(cacheRecord.refreshToken);\n        }\n\n        if (!!cacheRecord.appMetadata) {\n            this.setAppMetadata(cacheRecord.appMetadata);\n        }\n    }\n\n    /**\n     * saves access token credential\n     * @param credential\n     */\n    private async saveAccessToken(credential: AccessTokenEntity): Promise<void> {\n        const currentTokenCache = this.getCredentialsFilteredBy({\n            clientId: credential.clientId,\n            credentialType: credential.credentialType,\n            environment: credential.environment,\n            homeAccountId: credential.homeAccountId,\n            realm: credential.realm,\n            tokenType: credential.tokenType,\n            requestedClaimsHash: credential.requestedClaimsHash\n        });\n\n        const currentScopes = ScopeSet.fromString(credential.target);\n        const currentAccessTokens: AccessTokenEntity[] = Object.keys(currentTokenCache.accessTokens).map(key => currentTokenCache.accessTokens[key]);\n\n        if (currentAccessTokens) {\n            const removedAccessTokens: Array<Promise<boolean>> = [];\n            currentAccessTokens.forEach((tokenEntity) => {\n                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n                    removedAccessTokens.push(this.removeCredential(tokenEntity));\n                }\n            });\n            await Promise.all(removedAccessTokens);\n        }\n        this.setAccessTokenCredential(credential);\n    }\n\n    /**\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\n     * @param homeAccountId\n     * @param environment\n     * @param realm\n     */\n    getAccountsFilteredBy(accountFilter?: AccountFilter): AccountCache {\n        return this.getAccountsFilteredByInternal(\n            accountFilter ? accountFilter.homeAccountId : \"\",\n            accountFilter ? accountFilter.environment : \"\",\n            accountFilter ? accountFilter.realm : \"\"\n        );\n    }\n\n    /**\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\n     * @param homeAccountId\n     * @param environment\n     * @param realm\n     */\n    private getAccountsFilteredByInternal(\n        homeAccountId?: string,\n        environment?: string,\n        realm?: string\n    ): AccountCache {\n        const allCacheKeys = this.getKeys();\n        const matchingAccounts: AccountCache = {};\n\n        allCacheKeys.forEach((cacheKey) => {\n            const entity: AccountEntity | null = this.getAccount(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (!!homeAccountId && !this.matchHomeAccountId(entity, homeAccountId)) {\n                return;\n            }\n\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\n                return;\n            }\n\n            if (!!realm && !this.matchRealm(entity, realm)) {\n                return;\n            }\n\n            matchingAccounts[cacheKey] = entity;\n        });\n\n        return matchingAccounts;\n    }\n\n    /**\n     * retrieve credentails matching all provided filters; if no filter is set, get all credentials\n     * @param homeAccountId\n     * @param environment\n     * @param credentialType\n     * @param clientId\n     * @param realm\n     * @param target\n     */\n    getCredentialsFilteredBy(filter: CredentialFilter): CredentialCache {\n        return this.getCredentialsFilteredByInternal(\n            filter.homeAccountId,\n            filter.environment,\n            filter.credentialType,\n            filter.clientId,\n            filter.familyId,\n            filter.realm,\n            filter.target,\n            filter.oboAssertion,\n            filter.tokenType,\n            filter.keyId,\n            filter.requestedClaimsHash\n        );\n    }\n\n    /**\n     * Support function to help match credentials\n     * @param homeAccountId\n     * @param environment\n     * @param credentialType\n     * @param clientId\n     * @param realm\n     * @param target\n     * @param oboAssertion\n     * @param tokenType\n     */\n    private getCredentialsFilteredByInternal(\n        homeAccountId?: string,\n        environment?: string,\n        credentialType?: string,\n        clientId?: string,\n        familyId?: string,\n        realm?: string,\n        target?: string,\n        oboAssertion?: string,\n        tokenType?: AuthenticationScheme,\n        keyId?: string,\n        requestedClaimsHash?: string\n    ): CredentialCache {\n        const allCacheKeys = this.getKeys();\n        const matchingCredentials: CredentialCache = {\n            idTokens: {},\n            accessTokens: {},\n            refreshTokens: {},\n        };\n        \n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-credential type cache entities\n            const credType = CredentialEntity.getCredentialType(cacheKey);\n\n            if (credType === Constants.NOT_DEFINED) {\n                return;\n            }\n\n            // Attempt retrieval\n            const entity = this.getSpecificCredential(cacheKey, credType);\n\n            if (!entity) {\n                return;\n            }\n\n            if (!!oboAssertion && !this.matchOboAssertion(entity, oboAssertion)) {\n                return;\n            }\n\n            if (!!homeAccountId && !this.matchHomeAccountId(entity, homeAccountId)) {\n                return;\n            }\n\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\n                return;\n            }\n\n            if (!!realm && !this.matchRealm(entity, realm)) {\n                return;\n            }\n\n            if (!!credentialType && !this.matchCredentialType(entity, credentialType)) {\n                return;\n            }\n\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\n                return;\n            }\n\n            if (!!familyId && !this.matchFamilyId(entity, familyId)) {\n                return;\n            }\n\n            /*\n             * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\n             * Resource specific refresh tokens case will be added when the support is deemed necessary\n             */\n            if (!!target && !this.matchTarget(entity, target)) {\n                return;\n            }\n            \n            // If request OR cached entity has requested Claims Hash, check if they match\n            if (requestedClaimsHash || entity.requestedClaimsHash) {\n                // Don't match if either is undefined or they are different\n                if (entity.requestedClaimsHash !== requestedClaimsHash) {\n                    return;\n                }\n            }\n\n            // Access Token with Auth Scheme specific matching\n            if (credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n                if(!!tokenType && !this.matchTokenType(entity, tokenType)) {\n                    return;\n                }\n\n                // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n                if (tokenType === AuthenticationScheme.SSH) {\n                    if(keyId && !this.matchKeyId(entity, keyId)) {\n                        return;\n                    }\n                }\n            }\n\n            // At this point, the entity matches the request, update cache key if key schema has changed\n            const updatedCacheKey = this.updateCredentialCacheKey(cacheKey, entity);\n\n            switch (credType) {\n                case CredentialType.ID_TOKEN:\n                    matchingCredentials.idTokens[updatedCacheKey] = entity as IdTokenEntity;\n                    break;\n                case CredentialType.ACCESS_TOKEN:\n                case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                    matchingCredentials.accessTokens[updatedCacheKey] = entity as AccessTokenEntity;\n                    break;\n                case CredentialType.REFRESH_TOKEN:\n                    matchingCredentials.refreshTokens[updatedCacheKey] = entity as RefreshTokenEntity;\n                    break;\n            }\n        });\n\n        return matchingCredentials;\n    }\n\n    /**\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\n     * @param filter\n     */\n    getAppMetadataFilteredBy(filter: AppMetadataFilter): AppMetadataCache {\n        return this.getAppMetadataFilteredByInternal(\n            filter.environment,\n            filter.clientId,\n        );\n    }\n\n    /**\n     * Support function to help match appMetadata\n     * @param environment\n     * @param clientId\n     */\n    private getAppMetadataFilteredByInternal(\n        environment?: string,\n        clientId?: string\n    ): AppMetadataCache {\n\n        const allCacheKeys = this.getKeys();\n        const matchingAppMetadata: AppMetadataCache = {};\n\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-appMetadata type cache entities\n            if (!this.isAppMetadata(cacheKey)) {\n                return;\n            }\n\n            // Attempt retrieval\n            const entity = this.getAppMetadata(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\n                return;\n            }\n\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\n                return;\n            }\n\n            matchingAppMetadata[cacheKey] = entity;\n\n        });\n\n        return matchingAppMetadata;\n    }\n\n    /**\n     * retrieve authorityMetadata that contains a matching alias\n     * @param filter\n     */\n    getAuthorityMetadataByAlias(host: string): AuthorityMetadataEntity | null {\n        const allCacheKeys = this.getAuthorityMetadataKeys();\n        let matchedEntity = null;\n\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-authorityMetadata type cache entities\n            if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {\n                return;\n            }\n\n            // Attempt retrieval\n            const entity = this.getAuthorityMetadata(cacheKey);\n\n            if (!entity) {\n                return;\n            }\n\n            if (entity.aliases.indexOf(host) === -1) {\n                return;\n            }\n\n            matchedEntity = entity;\n\n        });\n        \n        return matchedEntity;\n    }\n\n    /**\n     * Removes all accounts and related tokens from cache.\n     */\n    async removeAllAccounts(): Promise<boolean> {\n        const allCacheKeys = this.getKeys();\n        const removedAccounts: Array<Promise<boolean>> = [];\n\n        allCacheKeys.forEach((cacheKey) => {\n            const entity = this.getAccount(cacheKey);\n            if (!entity) {\n                return;\n            }\n            removedAccounts.push(this.removeAccount(cacheKey));\n        });\n        \n        await Promise.all(removedAccounts);\n        return true;\n    }\n\n    /**\n     * returns a boolean if the given account is removed\n     * @param account\n     */\n    async removeAccount(accountKey: string): Promise<boolean> {\n        const account = this.getAccount(accountKey);\n        if (!account) {\n            throw ClientAuthError.createNoAccountFoundError();\n        }\n        return (await this.removeAccountContext(account) && this.removeItem(accountKey, CacheSchemaType.ACCOUNT));\n    }\n\n    /**\n     * returns a boolean if the given account is removed\n     * @param account\n     */\n    async removeAccountContext(account: AccountEntity): Promise<boolean> {\n        const allCacheKeys = this.getKeys();\n        const accountId = account.generateAccountId();\n        const removedCredentials: Array<Promise<boolean>> = [];\n\n        allCacheKeys.forEach((cacheKey) => {\n            // don't parse any non-credential type cache entities\n            const credType = CredentialEntity.getCredentialType(cacheKey);\n            if (credType === Constants.NOT_DEFINED) {\n                return;\n            }\n\n            const cacheEntity = this.getSpecificCredential(cacheKey, credType);\n            if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {\n                removedCredentials.push(this.removeCredential(cacheEntity));\n            }\n        });\n\n        await Promise.all(removedCredentials);\n        return true;\n    }\n\n    /**\n     * returns a boolean if the given credential is removed\n     * @param credential\n     */\n    async removeCredential(credential: CredentialEntity): Promise<boolean> {\n        const key = credential.generateCredentialKey();\n\n        // Remove Token Binding Key from key store for PoP Tokens Credentials\n        if (credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase()) {\n            if(credential.tokenType === AuthenticationScheme.POP) {\n                const accessTokenWithAuthSchemeEntity = credential as AccessTokenEntity;\n                const kid = accessTokenWithAuthSchemeEntity.keyId;\n    \n                if (kid) {\n                    try {\n                        await this.cryptoImpl.removeTokenBindingKey(kid);\n                    } catch (error) {\n                        throw ClientAuthError.createBindingKeyNotRemovedError();\n                    }\n                }\n            }\n        }\n\n        return this.removeItem(key, CacheSchemaType.CREDENTIAL);\n    }\n\n    /**\n     * Removes all app metadata objects from cache.\n     */\n    removeAppMetadata(): boolean {\n        const allCacheKeys = this.getKeys();\n        allCacheKeys.forEach((cacheKey) => {\n            if (this.isAppMetadata(cacheKey)) {\n                this.removeItem(cacheKey, CacheSchemaType.APP_METADATA);\n            }\n        });\n\n        return true;\n    }\n\n    /**\n     * Retrieve the cached credentials into a cacherecord\n     * @param account\n     * @param clientId\n     * @param scopes\n     * @param environment\n     * @param authScheme\n     */\n    readCacheRecord(account: AccountInfo, clientId: string, request: BaseAuthRequest, environment: string): CacheRecord {\n\n        const cachedAccount = this.readAccountFromCache(account);\n        const cachedIdToken = this.readIdTokenFromCache(clientId, account);\n        const cachedAccessToken = this.readAccessTokenFromCache(clientId, account, request);\n        const cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);\n        const cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);\n\n        if (cachedAccount && cachedIdToken) {\n            cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\n        }\n\n        return {\n            account: cachedAccount,\n            idToken: cachedIdToken,\n            accessToken: cachedAccessToken,\n            refreshToken: cachedRefreshToken,\n            appMetadata: cachedAppMetadata,\n        };\n    }\n\n    /**\n     * Retrieve AccountEntity from cache\n     * @param account\n     */\n    readAccountFromCache(account: AccountInfo): AccountEntity | null {\n        const accountKey: string = AccountEntity.generateAccountCacheKey(account);\n        return this.getAccount(accountKey);\n    }\n\n    /**\n     * Retrieve IdTokenEntity from cache\n     * @param clientId\n     * @param account\n     * @param inputRealm\n     */\n    readIdTokenFromCache(clientId: string, account: AccountInfo): IdTokenEntity | null {\n        const idTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: CredentialType.ID_TOKEN,\n            clientId: clientId,\n            realm: account.tenantId,\n        };\n\n        const credentialCache: CredentialCache = this.getCredentialsFilteredBy(idTokenFilter);\n        const idTokens = Object.keys(credentialCache.idTokens).map((key) => credentialCache.idTokens[key]);\n        const numIdTokens = idTokens.length;\n\n        if (numIdTokens < 1) {\n            return null;\n        } else if (numIdTokens > 1) {\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n        }\n\n        return idTokens[0] as IdTokenEntity;\n    }\n\n    /**\n     * Retrieve AccessTokenEntity from cache\n     * @param clientId\n     * @param account\n     * @param scopes\n     * @param authScheme\n     */\n    readAccessTokenFromCache(clientId: string, account: AccountInfo, request: BaseAuthRequest): AccessTokenEntity | null {\n        const scopes =  new ScopeSet(request.scopes || []);\n        const authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n        /*\n         * Distinguish between Bearer and PoP/SSH token cache types\n         * Cast to lowercase to handle \"bearer\" from ADFS\n         */\n        const credentialType = (authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n\n        const accessTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: credentialType,\n            clientId,\n            realm: account.tenantId,\n            target: scopes.printScopesLowerCase(),\n            tokenType: authScheme,\n            keyId: request.sshKid,\n            requestedClaimsHash: request.requestedClaimsHash\n        };\n\n        const credentialCache: CredentialCache = this.getCredentialsFilteredBy(accessTokenFilter);\n        \n        const accessTokens = Object.keys(credentialCache.accessTokens).map((key) => credentialCache.accessTokens[key]);\n        \n        const numAccessTokens = accessTokens.length;\n        if (numAccessTokens < 1) {\n            return null;\n        } else if (numAccessTokens > 1) {\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n        }\n\n        return accessTokens[0] as AccessTokenEntity;\n    }\n\n    /**\n     * Helper to retrieve the appropriate refresh token from cache\n     * @param clientId\n     * @param account\n     * @param familyRT\n     */\n    readRefreshTokenFromCache(clientId: string, account: AccountInfo, familyRT: boolean): RefreshTokenEntity | null {\n        const id = familyRT ? THE_FAMILY_ID : undefined;\n        const refreshTokenFilter: CredentialFilter = {\n            homeAccountId: account.homeAccountId,\n            environment: account.environment,\n            credentialType: CredentialType.REFRESH_TOKEN,\n            clientId: clientId,\n            familyId: id\n        };\n\n        const credentialCache: CredentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);\n        const refreshTokens = Object.keys(credentialCache.refreshTokens).map((key) => credentialCache.refreshTokens[key]);\n\n        const numRefreshTokens = refreshTokens.length;\n        if (numRefreshTokens < 1) {\n            return null;\n        }\n        // address the else case after remove functions address environment aliases\n\n        return refreshTokens[0] as RefreshTokenEntity;\n    }\n\n    /**\n     * Retrieve AppMetadataEntity from cache\n     */\n    readAppMetadataFromCache(environment: string, clientId: string): AppMetadataEntity | null {\n        const appMetadataFilter: AppMetadataFilter = {\n            environment,\n            clientId,\n        };\n\n        const appMetadata: AppMetadataCache = this.getAppMetadataFilteredBy(appMetadataFilter);\n        const appMetadataEntries: AppMetadataEntity[] = Object.keys(appMetadata).map((key) => appMetadata[key]);\n\n        const numAppMetadata = appMetadataEntries.length;\n        if (numAppMetadata < 1) {\n            return null;\n        } else if (numAppMetadata > 1) {\n            throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\n        }\n\n        return appMetadataEntries[0] as AppMetadataEntity;\n    }\n\n    /**\n     * Return the family_id value associated  with FOCI\n     * @param environment\n     * @param clientId\n     */\n    isAppMetadataFOCI(environment: string, clientId: string): boolean {\n        const appMetadata = this.readAppMetadataFromCache(environment, clientId);\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n    }\n\n    /**\n     * helper to match account ids\n     * @param value\n     * @param homeAccountId\n     */\n    private matchHomeAccountId(entity: AccountEntity | CredentialEntity, homeAccountId: string): boolean {\n        return !!(entity.homeAccountId && homeAccountId === entity.homeAccountId);\n    }\n\n    /**\n     * helper to match assertion\n     * @param value\n     * @param oboAssertion\n     */\n    private matchOboAssertion(entity: AccountEntity | CredentialEntity, oboAssertion: string): boolean {\n        return !!(entity.oboAssertion && oboAssertion === entity.oboAssertion);\n    }\n\n    /**\n     * helper to match environment\n     * @param value\n     * @param environment\n     */\n    private matchEnvironment(entity: AccountEntity | CredentialEntity | AppMetadataEntity, environment: string): boolean {\n        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * helper to match credential type\n     * @param entity\n     * @param credentialType\n     */\n    private matchCredentialType(entity: CredentialEntity, credentialType: string): boolean {\n        return (entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase());\n    }\n\n    /**\n     * helper to match client ids\n     * @param entity\n     * @param clientId\n     */\n    private matchClientId(entity: CredentialEntity | AppMetadataEntity, clientId: string): boolean {\n        return !!(entity.clientId && clientId === entity.clientId);\n    }\n\n    /**\n     * helper to match family ids\n     * @param entity\n     * @param familyId\n     */\n    private matchFamilyId(entity: CredentialEntity | AppMetadataEntity, familyId: string): boolean {\n        return !!(entity.familyId && familyId === entity.familyId);\n    }\n\n    /**\n     * helper to match realm\n     * @param entity\n     * @param realm\n     */\n    private matchRealm(entity: AccountEntity | CredentialEntity, realm: string): boolean {\n        return !!(entity.realm && realm === entity.realm);\n    }\n\n    /**\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\n     * @param entity\n     * @param target\n     */\n    private matchTarget(entity: CredentialEntity, target: string): boolean {\n        const isNotAccessTokenCredential = (entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\n\n        if ( isNotAccessTokenCredential || !entity.target) {\n            return false;\n        }\n\n        const entityScopeSet: ScopeSet = ScopeSet.fromString(entity.target);\n        const requestTargetScopeSet: ScopeSet = ScopeSet.fromString(target);\n\n        if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {\n            requestTargetScopeSet.removeOIDCScopes(); // ignore OIDC scopes\n        } else {\n            requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);\n        }\n        return entityScopeSet.containsScopeSet(requestTargetScopeSet);\n    }\n\n    /**\n     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\n     * @param entity \n     * @param tokenType \n     */\n    private matchTokenType(entity: CredentialEntity, tokenType: AuthenticationScheme): boolean {\n        return !!(entity.tokenType && entity.tokenType === tokenType);\n    }\n\n    /**\n     * Returns true if the credential's keyId matches the one in the request, false otherwise\n     * @param entity \n     * @param tokenType \n     */\n    private matchKeyId(entity: CredentialEntity, keyId: string): boolean {\n        return !!(entity.keyId && entity.keyId === keyId);\n    }\n\n    /**\n     * returns if a given cache entity is of the type appmetadata\n     * @param key\n     */\n    private isAppMetadata(key: string): boolean {\n        return key.indexOf(APP_METADATA) !== -1;\n    }\n\n    /**\n     * returns if a given cache entity is of the type authoritymetadata\n     * @param key\n     */\n    protected isAuthorityMetadata(key: string): boolean {\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n    }\n\n    /**\n     * returns cache key used for cloud instance metadata\n     */\n    generateAuthorityMetadataCacheKey(authority: string): string {\n        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\n    }\n\n    /**\n     * Returns the specific credential (IdToken/AccessToken/RefreshToken) from the cache\n     * @param key\n     * @param credType\n     */\n    private getSpecificCredential(key: string, credType: string): ValidCredentialType | null {\n        switch (credType) {\n            case CredentialType.ID_TOKEN: {\n                return this.getIdTokenCredential(key);\n            }\n            case CredentialType.ACCESS_TOKEN:\n            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME: {\n                return this.getAccessTokenCredential(key);\n            }\n            case CredentialType.REFRESH_TOKEN: {\n                return this.getRefreshTokenCredential(key);\n            }\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Helper to convert serialized data to object\n     * @param obj\n     * @param json\n     */\n    static toObject<T>(obj: T, json: object): T {\n        for (const propertyName in json) {\n            obj[propertyName] = json[propertyName];\n        }\n        return obj;\n    }\n}\n\nexport class DefaultStorageClass extends CacheManager {\n    setAccount(): void {\n        const notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAccount(): AccountEntity {\n        const notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setIdTokenCredential(): void {\n        const notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getIdTokenCredential(): IdTokenEntity {\n        const notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setAccessTokenCredential(): void {\n        const notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAccessTokenCredential(): AccessTokenEntity {\n        const notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setRefreshTokenCredential(): void {\n        const notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getRefreshTokenCredential(): RefreshTokenEntity {\n        const notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setAppMetadata(): void {\n        const notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAppMetadata(): AppMetadataEntity {\n        const notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setServerTelemetry(): void {\n        const notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getServerTelemetry(): ServerTelemetryEntity {\n        const notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setAuthorityMetadata(): void {\n        const notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAuthorityMetadata(): AuthorityMetadataEntity | null {\n        const notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getAuthorityMetadataKeys(): Array<string> {\n        const notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    setThrottlingCache(): void {\n        const notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getThrottlingCache(): ThrottlingEntity {\n        const notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    removeItem(): boolean {\n        const notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    containsKey(): boolean {\n        const notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    getKeys(): string[] {\n        const notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    async clear(): Promise<void> {\n        const notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n    updateCredentialCacheKey(): string {\n        const notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n    }\n}\n"]},"metadata":{},"sourceType":"module"}