{"ast":null,"code":"/*! @azure/msal-common v6.1.0 2022-02-08 */\n'use strict';\n\nimport { __extends } from '../../_virtual/_tslib.js';\nimport { CredentialEntity } from './CredentialEntity.js';\nimport { CredentialType, AuthenticationScheme } from '../../utils/Constants.js';\nimport { TimeUtils } from '../../utils/TimeUtils.js';\nimport { StringUtils } from '../../utils/StringUtils.js';\nimport { AuthToken } from '../../account/AuthToken.js';\nimport { ClientAuthError } from '../../error/ClientAuthError.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * ACCESS_TOKEN Credential Type\r\n *\r\n * Key:Value Schema:\r\n *\r\n * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read\r\n *\r\n * Value Schema:\r\n * {\r\n *      homeAccountId: home account identifier for the auth scheme,\r\n *      environment: entity that issued the token, represented as a full host\r\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\r\n *      clientId: client ID of the application\r\n *      secret: Actual credential as a string\r\n *      familyId: Family ID identifier, usually only used for refresh tokens\r\n *      realm: Full tenant or organizational identifier that the account belongs to\r\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\r\n *      cachedAt: Absolute device time when entry was created in the cache.\r\n *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.\r\n *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.\r\n *      keyId: used for POP and SSH tokenTypes\r\n *      tokenType: Type of the token issued. Usually \"Bearer\"\r\n * }\r\n */\n\nvar AccessTokenEntity =\n/** @class */\nfunction (_super) {\n  __extends(AccessTokenEntity, _super);\n\n  function AccessTokenEntity() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\r\n   * Create AccessTokenEntity\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param accessToken\r\n   * @param clientId\r\n   * @param tenantId\r\n   * @param scopes\r\n   * @param expiresOn\r\n   * @param extExpiresOn\r\n   */\n\n\n  AccessTokenEntity.createAccessTokenEntity = function (homeAccountId, environment, accessToken, clientId, tenantId, scopes, expiresOn, extExpiresOn, cryptoUtils, refreshOn, tokenType, oboAssertion, keyId, requestedClaims, requestedClaimsHash) {\n    var _a, _b;\n\n    var atEntity = new AccessTokenEntity();\n    atEntity.homeAccountId = homeAccountId;\n    atEntity.credentialType = CredentialType.ACCESS_TOKEN;\n    atEntity.secret = accessToken;\n    var currentTime = TimeUtils.nowSeconds();\n    atEntity.cachedAt = currentTime.toString();\n    /*\r\n     * Token expiry time.\r\n     * This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.\r\n     */\n\n    atEntity.expiresOn = expiresOn.toString();\n    atEntity.extendedExpiresOn = extExpiresOn.toString();\n\n    if (refreshOn) {\n      atEntity.refreshOn = refreshOn.toString();\n    }\n\n    atEntity.environment = environment;\n    atEntity.clientId = clientId;\n    atEntity.realm = tenantId;\n    atEntity.target = scopes;\n    atEntity.oboAssertion = oboAssertion;\n    atEntity.tokenType = StringUtils.isEmpty(tokenType) ? AuthenticationScheme.BEARER : tokenType;\n\n    if (requestedClaims) {\n      atEntity.requestedClaims = requestedClaims;\n      atEntity.requestedClaimsHash = requestedClaimsHash;\n    }\n    /*\r\n     * Create Access Token With Auth Scheme instead of regular access token\r\n     * Cast to lower to handle \"bearer\" from ADFS\r\n     */\n\n\n    if (((_a = atEntity.tokenType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== AuthenticationScheme.BEARER.toLowerCase()) {\n      atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n\n      switch (atEntity.tokenType) {\n        case AuthenticationScheme.POP:\n          // Make sure keyId is present and add it to credential\n          var tokenClaims = AuthToken.extractTokenClaims(accessToken, cryptoUtils);\n\n          if (!((_b = tokenClaims === null || tokenClaims === void 0 ? void 0 : tokenClaims.cnf) === null || _b === void 0 ? void 0 : _b.kid)) {\n            throw ClientAuthError.createTokenClaimsRequiredError();\n          }\n\n          atEntity.keyId = tokenClaims.cnf.kid;\n          break;\n\n        case AuthenticationScheme.SSH:\n          atEntity.keyId = keyId;\n      }\n    }\n\n    return atEntity;\n  };\n  /**\r\n   * Validates an entity: checks for all expected params\r\n   * @param entity\r\n   */\n\n\n  AccessTokenEntity.isAccessTokenEntity = function (entity) {\n    if (!entity) {\n      return false;\n    }\n\n    return entity.hasOwnProperty(\"homeAccountId\") && entity.hasOwnProperty(\"environment\") && entity.hasOwnProperty(\"credentialType\") && entity.hasOwnProperty(\"realm\") && entity.hasOwnProperty(\"clientId\") && entity.hasOwnProperty(\"secret\") && entity.hasOwnProperty(\"target\") && (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN || entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\n  };\n\n  return AccessTokenEntity;\n}(CredentialEntity);\n\nexport { AccessTokenEntity };","map":{"version":3,"mappings":"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","names":["__extends","AccessTokenEntity","homeAccountId","environment","accessToken","clientId","tenantId","scopes","expiresOn","extExpiresOn","cryptoUtils","refreshOn","tokenType","oboAssertion","keyId","requestedClaims","requestedClaimsHash","atEntity","credentialType","CredentialType","ACCESS_TOKEN","secret","currentTime","TimeUtils","nowSeconds","cachedAt","toString","extendedExpiresOn","realm","target","StringUtils","isEmpty","AuthenticationScheme","BEARER","_a","toLowerCase","ACCESS_TOKEN_WITH_AUTH_SCHEME","POP","tokenClaims","AuthToken","extractTokenClaims","cnf","_b","kid","ClientAuthError","createTokenClaimsRequiredError","SSH","entity","hasOwnProperty","CredentialEntity"],"sources":["C:\\Users\\empti\\OneDrive\\Desktop\\User_Interface\\user_interface_frontend\\node_modules\\@azure\\msal-common\\src\\cache\\entities\\AccessTokenEntity.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { CredentialEntity } from \"./CredentialEntity\";\nimport { CredentialType, AuthenticationScheme } from \"../../utils/Constants\";\nimport { TimeUtils } from \"../../utils/TimeUtils\";\nimport { StringUtils } from \"../../utils/StringUtils\";\nimport { ICrypto } from \"../../crypto/ICrypto\";\nimport { TokenClaims } from \"../../account/TokenClaims\";\nimport { AuthToken } from \"../../account/AuthToken\";\nimport { ClientAuthError } from \"../../error/ClientAuthError\";\n\n/**\n * ACCESS_TOKEN Credential Type\n *\n * Key:Value Schema:\n *\n * Key Example: uid.utid-login.microsoftonline.com-accesstoken-clientId-contoso.com-user.read\n *\n * Value Schema:\n * {\n *      homeAccountId: home account identifier for the auth scheme,\n *      environment: entity that issued the token, represented as a full host\n *      credentialType: Type of credential as a string, can be one of the following: RefreshToken, AccessToken, IdToken, Password, Cookie, Certificate, Other\n *      clientId: client ID of the application\n *      secret: Actual credential as a string\n *      familyId: Family ID identifier, usually only used for refresh tokens\n *      realm: Full tenant or organizational identifier that the account belongs to\n *      target: Permissions that are included in the token, or for refresh tokens, the resource identifier.\n *      cachedAt: Absolute device time when entry was created in the cache.\n *      expiresOn: Token expiry time, calculated based on current UTC time in seconds. Represented as a string.\n *      extendedExpiresOn: Additional extended expiry time until when token is valid in case of server-side outage. Represented as string in UTC seconds.\n *      keyId: used for POP and SSH tokenTypes\n *      tokenType: Type of the token issued. Usually \"Bearer\"\n * }\n */\nexport class AccessTokenEntity extends CredentialEntity {\n    realm: string;\n    target: string;\n    cachedAt: string;\n    expiresOn: string;\n    extendedExpiresOn?: string;\n    refreshOn?: string;\n    keyId?: string; // for POP and SSH tokenTypes\n    tokenType?: AuthenticationScheme;\n    requestedClaims?: string;\n    requestedClaimsHash?: string;\n\n    /**\n     * Create AccessTokenEntity\n     * @param homeAccountId\n     * @param environment\n     * @param accessToken\n     * @param clientId\n     * @param tenantId\n     * @param scopes\n     * @param expiresOn\n     * @param extExpiresOn\n     */\n    static createAccessTokenEntity(\n        homeAccountId: string,\n        environment: string,\n        accessToken: string,\n        clientId: string,\n        tenantId: string,\n        scopes: string,\n        expiresOn: number,\n        extExpiresOn: number,\n        cryptoUtils: ICrypto,\n        refreshOn?: number,\n        tokenType?: AuthenticationScheme,\n        oboAssertion?: string,\n        keyId?: string,\n        requestedClaims?: string,\n        requestedClaimsHash?: string \n    ): AccessTokenEntity {\n        const atEntity: AccessTokenEntity = new AccessTokenEntity();\n\n        atEntity.homeAccountId = homeAccountId;\n        atEntity.credentialType = CredentialType.ACCESS_TOKEN;\n        atEntity.secret = accessToken;\n\n        const currentTime = TimeUtils.nowSeconds();\n        atEntity.cachedAt = currentTime.toString();\n\n        /*\n         * Token expiry time.\n         * This value should be  calculated based on the current UTC time measured locally and the value  expires_in Represented as a string in JSON.\n         */\n        atEntity.expiresOn = expiresOn.toString();\n        atEntity.extendedExpiresOn = extExpiresOn.toString();\n        if (refreshOn) {\n            atEntity.refreshOn = refreshOn.toString();\n        }\n\n        atEntity.environment = environment;\n        atEntity.clientId = clientId;\n        atEntity.realm = tenantId;\n        atEntity.target = scopes;\n        atEntity.oboAssertion = oboAssertion;\n\n        atEntity.tokenType = StringUtils.isEmpty(tokenType) ? AuthenticationScheme.BEARER : tokenType;\n\n        if (requestedClaims) {\n            atEntity.requestedClaims = requestedClaims;\n            atEntity.requestedClaimsHash = requestedClaimsHash;\n        }\n\n        /*\n         * Create Access Token With Auth Scheme instead of regular access token\n         * Cast to lower to handle \"bearer\" from ADFS\n         */\n        if (atEntity.tokenType?.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) {\n            atEntity.credentialType = CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n            switch (atEntity.tokenType) {\n                case AuthenticationScheme.POP:\n                    // Make sure keyId is present and add it to credential\n                    const tokenClaims: TokenClaims | null = AuthToken.extractTokenClaims(accessToken, cryptoUtils);\n                    if (!tokenClaims?.cnf?.kid) {\n                        throw ClientAuthError.createTokenClaimsRequiredError();\n                    }\n                    atEntity.keyId = tokenClaims.cnf.kid;\n                    break;\n                case AuthenticationScheme.SSH:\n                    atEntity.keyId = keyId;\n            }\n        }\n\n        return atEntity;\n    }\n\n    /**\n     * Validates an entity: checks for all expected params\n     * @param entity\n     */\n    static isAccessTokenEntity(entity: object): boolean {\n\n        if (!entity) {\n            return false;\n        }\n\n        return (\n            entity.hasOwnProperty(\"homeAccountId\") &&\n            entity.hasOwnProperty(\"environment\") &&\n            entity.hasOwnProperty(\"credentialType\") &&\n            entity.hasOwnProperty(\"realm\") &&\n            entity.hasOwnProperty(\"clientId\") &&\n            entity.hasOwnProperty(\"secret\") &&\n            entity.hasOwnProperty(\"target\") &&\n            (entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN || entity[\"credentialType\"] === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME)\n        );\n    }\n}\n"]},"metadata":{},"sourceType":"module"}