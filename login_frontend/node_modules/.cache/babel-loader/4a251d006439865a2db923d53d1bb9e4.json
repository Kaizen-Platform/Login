{"ast":null,"code":"/*! @azure/msal-browser v2.22.0 2022-02-08 */\n'use strict';\n\nimport { __extends, __spread, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { AccountEntity, CacheManager, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, ServerTelemetryEntity, AuthorityMetadataEntity, PersistentCacheKeys, ThrottlingEntity, StringUtils, Constants, ProtocolUtils, CcsCredentialType, IdToken, DEFAULT_CRYPTO_IMPLEMENTATION } from '@azure/msal-common';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { BrowserCacheLocation, InMemoryCacheKeys, TemporaryCacheKeys } from '../utils/BrowserConstants.js';\nimport { BrowserStorage } from './BrowserStorage.js';\nimport { MemoryStorage } from './MemoryStorage.js';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\n\nvar BrowserCacheManager =\n/** @class */\nfunction (_super) {\n  __extends(BrowserCacheManager, _super);\n\n  function BrowserCacheManager(clientId, cacheConfig, cryptoImpl, logger) {\n    var _this = _super.call(this, clientId, cryptoImpl) || this; // Cookie life calculation (hours * minutes * seconds * ms)\n\n\n    _this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\n    _this.cacheConfig = cacheConfig;\n    _this.logger = logger;\n    _this.internalStorage = new MemoryStorage();\n    _this.browserStorage = _this.setupBrowserStorage(_this.cacheConfig.cacheLocation);\n    _this.temporaryCacheStorage = _this.setupTemporaryCacheStorage(_this.cacheConfig.cacheLocation); // Migrate any cache entries from older versions of MSAL.\n\n    _this.migrateCacheEntries();\n\n    return _this;\n  }\n  /**\r\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n   * @param cacheLocation\r\n   */\n\n\n  BrowserCacheManager.prototype.setupBrowserStorage = function (cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n          return new BrowserStorage(cacheLocation);\n        } catch (e) {\n          this.logger.verbose(e);\n          break;\n        }\n\n    }\n\n    this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n    return new MemoryStorage();\n  };\n  /**\r\n   *\r\n   * @param cacheLocation\r\n   */\n\n\n  BrowserCacheManager.prototype.setupTemporaryCacheStorage = function (cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n          return new BrowserStorage(BrowserCacheLocation.SessionStorage);\n        } catch (e) {\n          this.logger.verbose(e);\n          return this.internalStorage;\n        }\n\n      case BrowserCacheLocation.MemoryStorage:\n      default:\n        return this.internalStorage;\n    }\n  };\n  /**\r\n   * Migrate all old cache entries to new schema. No rollback supported.\r\n   * @param storeAuthStateInCookie\r\n   */\n\n\n  BrowserCacheManager.prototype.migrateCacheEntries = function () {\n    var _this = this;\n\n    var idTokenKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ID_TOKEN;\n    var clientInfoKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.CLIENT_INFO;\n    var errorKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR;\n    var errorDescKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR_DESC;\n    var idTokenValue = this.browserStorage.getItem(idTokenKey);\n    var clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n    var errorValue = this.browserStorage.getItem(errorKey);\n    var errorDescValue = this.browserStorage.getItem(errorDescKey);\n    var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n    var keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\n    keysToMigrate.forEach(function (cacheKey, index) {\n      return _this.migrateCacheEntry(cacheKey, values[index]);\n    });\n  };\n  /**\r\n   * Utility function to help with migration.\r\n   * @param newKey\r\n   * @param value\r\n   * @param storeAuthStateInCookie\r\n   */\n\n\n  BrowserCacheManager.prototype.migrateCacheEntry = function (newKey, value) {\n    if (value) {\n      this.setTemporaryCache(newKey, value, true);\n    }\n  };\n  /**\r\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n   * @param input\r\n   */\n\n\n  BrowserCacheManager.prototype.validateAndParseJson = function (jsonValue) {\n    try {\n      var parsedJson = JSON.parse(jsonValue);\n      /**\r\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n       *\r\n       */\n\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  };\n  /**\r\n   * fetches the entry from the browser storage based off the key\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getItem = function (key) {\n    return this.browserStorage.getItem(key);\n  };\n  /**\r\n   * sets the entry in the browser storage\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setItem = function (key, value) {\n    this.browserStorage.setItem(key, value);\n  };\n  /**\r\n   * fetch the account entity from the platform cache\r\n   * @param accountKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccount = function (accountKey) {\n    var account = this.getItem(accountKey);\n\n    if (!account) {\n      return null;\n    }\n\n    var parsedAccount = this.validateAndParseJson(account);\n\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      return null;\n    }\n\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  };\n  /**\r\n   * set account entity in the platform cache\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setAccount = function (account) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    var key = account.generateAccountKey();\n    this.setItem(key, JSON.stringify(account));\n  };\n  /**\r\n   * generates idToken entity from a string\r\n   * @param idTokenKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getIdTokenCredential = function (idTokenKey) {\n    var value = this.getItem(idTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    var parsedIdToken = this.validateAndParseJson(value);\n\n    if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\n  };\n  /**\r\n   * set IdToken credential to the platform cache\r\n   * @param idToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setIdTokenCredential = function (idToken) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    var idTokenKey = idToken.generateCredentialKey();\n    this.setItem(idTokenKey, JSON.stringify(idToken));\n  };\n  /**\r\n   * generates accessToken entity from a string\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccessTokenCredential = function (accessTokenKey) {\n    var value = this.getItem(accessTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    var parsedAccessToken = this.validateAndParseJson(value);\n\n    if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\n  };\n  /**\r\n   * set accessToken credential to the platform cache\r\n   * @param accessToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setAccessTokenCredential = function (accessToken) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    var accessTokenKey = accessToken.generateCredentialKey();\n    this.setItem(accessTokenKey, JSON.stringify(accessToken));\n  };\n  /**\r\n   * generates refreshToken entity from a string\r\n   * @param refreshTokenKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getRefreshTokenCredential = function (refreshTokenKey) {\n    var value = this.getItem(refreshTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    var parsedRefreshToken = this.validateAndParseJson(value);\n\n    if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\n  };\n  /**\r\n   * set refreshToken credential to the platform cache\r\n   * @param refreshToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setRefreshTokenCredential = function (refreshToken) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    var refreshTokenKey = refreshToken.generateCredentialKey();\n    this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\n  };\n  /**\r\n   * fetch appMetadata entity from the platform cache\r\n   * @param appMetadataKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getAppMetadata = function (appMetadataKey) {\n    var value = this.getItem(appMetadataKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\n  };\n  /**\r\n   * set appMetadata entity to the platform cache\r\n   * @param appMetadata\r\n   */\n\n\n  BrowserCacheManager.prototype.setAppMetadata = function (appMetadata) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    var appMetadataKey = appMetadata.generateAppMetadataKey();\n    this.setItem(appMetadataKey, JSON.stringify(appMetadata));\n  };\n  /**\r\n   * fetch server telemetry entity from the platform cache\r\n   * @param serverTelemetryKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getServerTelemetry = function (serverTelemetryKey) {\n    var value = this.getItem(serverTelemetryKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\n  };\n  /**\r\n   * set server telemetry entity to the platform cache\r\n   * @param serverTelemetryKey\r\n   * @param serverTelemetry\r\n   */\n\n\n  BrowserCacheManager.prototype.setServerTelemetry = function (serverTelemetryKey, serverTelemetry) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n  };\n  /**\r\n   *\r\n   */\n\n\n  BrowserCacheManager.prototype.getAuthorityMetadata = function (key) {\n    var value = this.internalStorage.getItem(key);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\n    }\n\n    return null;\n  };\n  /**\r\n   *\r\n   */\n\n\n  BrowserCacheManager.prototype.getAuthorityMetadataKeys = function () {\n    var _this = this;\n\n    var allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(function (key) {\n      return _this.isAuthorityMetadata(key);\n    });\n  };\n  /**\r\n   * Sets wrapper metadata in memory\r\n   * @param wrapperSKU\r\n   * @param wrapperVersion\r\n   */\n\n\n  BrowserCacheManager.prototype.setWrapperMetadata = function (wrapperSKU, wrapperVersion) {\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n  };\n  /**\r\n   * Returns wrapper metadata from in-memory storage\r\n   */\n\n\n  BrowserCacheManager.prototype.getWrapperMetadata = function () {\n    var sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || \"\";\n    var version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || \"\";\n    return [sku, version];\n  };\n  /**\r\n   *\r\n   * @param entity\r\n   */\n\n\n  BrowserCacheManager.prototype.setAuthorityMetadata = function (key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  };\n  /**\r\n   * Gets the active account\r\n   */\n\n\n  BrowserCacheManager.prototype.getActiveAccount = function () {\n    var activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n    var activeAccountId = this.browserStorage.getItem(activeAccountIdKey);\n\n    if (!activeAccountId) {\n      return null;\n    }\n\n    return this.getAccountInfoByFilter({\n      localAccountId: activeAccountId\n    })[0] || null;\n  };\n  /**\r\n   * Sets the active account's localAccountId in cache\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.setActiveAccount = function (account) {\n    var activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      this.browserStorage.setItem(activeAccountIdKey, account.localAccountId);\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountIdKey);\n    }\n  };\n  /**\r\n   * Gets a list of accounts that match all of the filters provided\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccountInfoByFilter = function (accountFilter) {\n    var allAccounts = this.getAllAccounts();\n    return allAccounts.filter(function (accountObj) {\n      if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\n        return false;\n      }\n\n      if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\n        return false;\n      }\n\n      if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\n        return false;\n      }\n\n      if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\n        return false;\n      }\n\n      if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\n        return false;\n      }\n\n      return true;\n    });\n  };\n  /**\r\n   * fetch throttling entity from the platform cache\r\n   * @param throttlingCacheKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getThrottlingCache = function (throttlingCacheKey) {\n    var value = this.getItem(throttlingCacheKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n\n    var parsedThrottlingCache = this.validateAndParseJson(value);\n\n    if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\n  };\n  /**\r\n   * set throttling entity to the platform cache\r\n   * @param throttlingCacheKey\r\n   * @param throttlingCache\r\n   */\n\n\n  BrowserCacheManager.prototype.setThrottlingCache = function (throttlingCacheKey, throttlingCache) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n  };\n  /**\r\n   * Gets cache item with given key.\r\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getTemporaryCache = function (cacheKey, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      var itemCookie = this.getItemCookie(key);\n\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n\n    var value = this.temporaryCacheStorage.getItem(key);\n\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        var item = this.browserStorage.getItem(key);\n\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  };\n  /**\r\n   * Sets the cache item with the key and value given.\r\n   * Stores in cookie if storeAuthStateInCookie is set to true.\r\n   * This can cause cookie overflow if used incorrectly.\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setTemporaryCache = function (cacheKey, value, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.setItemCookie(key, value);\n    }\n  };\n  /**\r\n   * Removes the cache item with the given key.\r\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeItem = function (key) {\n    this.browserStorage.removeItem(key);\n    this.temporaryCacheStorage.removeItem(key);\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.clearItemCookie(key);\n    }\n\n    return true;\n  };\n  /**\r\n   * Checks whether key is in cache.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.containsKey = function (key) {\n    return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\n  };\n  /**\r\n   * Gets all keys in window.\r\n   */\n\n\n  BrowserCacheManager.prototype.getKeys = function () {\n    return __spread(this.browserStorage.getKeys(), this.temporaryCacheStorage.getKeys());\n  };\n  /**\r\n   * Clears all cache entries created by MSAL.\r\n   */\n\n\n  BrowserCacheManager.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Removes all accounts and their credentials\n            return [4\n            /*yield*/\n            , this.removeAllAccounts()];\n\n          case 1:\n            // Removes all accounts and their credentials\n            _a.sent();\n\n            this.removeAppMetadata(); // Removes all remaining MSAL cache items\n\n            this.getKeys().forEach(function (cacheKey) {\n              // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\n              if ((_this.browserStorage.containsKey(cacheKey) || _this.temporaryCacheStorage.containsKey(cacheKey)) && (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(_this.clientId) !== -1)) {\n                _this.removeItem(cacheKey);\n              }\n            });\n            this.internalStorage.clear();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Add value to cookies\r\n   * @param cookieName\r\n   * @param cookieValue\r\n   * @param expires\r\n   */\n\n\n  BrowserCacheManager.prototype.setItemCookie = function (cookieName, cookieValue, expires) {\n    var cookieStr = encodeURIComponent(cookieName) + \"=\" + encodeURIComponent(cookieValue) + \";path=/;\";\n\n    if (expires) {\n      var expireTime = this.getCookieExpirationTime(expires);\n      cookieStr += \"expires=\" + expireTime + \";\";\n    }\n\n    if (this.cacheConfig.secureCookies) {\n      cookieStr += \"Secure;\";\n    }\n\n    document.cookie = cookieStr;\n  };\n  /**\r\n   * Get one item by key from cookies\r\n   * @param cookieName\r\n   */\n\n\n  BrowserCacheManager.prototype.getItemCookie = function (cookieName) {\n    var name = encodeURIComponent(cookieName) + \"=\";\n    var cookieList = document.cookie.split(\";\");\n\n    for (var i = 0; i < cookieList.length; i++) {\n      var cookie = cookieList[i];\n\n      while (cookie.charAt(0) === \" \") {\n        cookie = cookie.substring(1);\n      }\n\n      if (cookie.indexOf(name) === 0) {\n        return decodeURIComponent(cookie.substring(name.length, cookie.length));\n      }\n    }\n\n    return \"\";\n  };\n  /**\r\n   * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\r\n   */\n\n\n  BrowserCacheManager.prototype.clearMsalCookies = function () {\n    var _this = this;\n\n    var cookiePrefix = Constants.CACHE_PREFIX + \".\" + this.clientId;\n    var cookieList = document.cookie.split(\";\");\n    cookieList.forEach(function (cookie) {\n      while (cookie.charAt(0) === \" \") {\n        // eslint-disable-next-line no-param-reassign\n        cookie = cookie.substring(1);\n      }\n\n      if (cookie.indexOf(cookiePrefix) === 0) {\n        var cookieKey = cookie.split(\"=\")[0];\n\n        _this.clearItemCookie(cookieKey);\n      }\n    });\n  };\n  /**\r\n   * Clear an item in the cookies by key\r\n   * @param cookieName\r\n   */\n\n\n  BrowserCacheManager.prototype.clearItemCookie = function (cookieName) {\n    this.setItemCookie(cookieName, \"\", -1);\n  };\n  /**\r\n   * Get cookie expiration time\r\n   * @param cookieLifeDays\r\n   */\n\n\n  BrowserCacheManager.prototype.getCookieExpirationTime = function (cookieLifeDays) {\n    var today = new Date();\n    var expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\n    return expr.toUTCString();\n  };\n  /**\r\n   * Gets the cache object referenced by the browser\r\n   */\n\n\n  BrowserCacheManager.prototype.getCache = function () {\n    return this.browserStorage;\n  };\n  /**\r\n   * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\r\n   */\n\n\n  BrowserCacheManager.prototype.setCache = function () {// sets nothing\n  };\n  /**\r\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n   * @param key\r\n   * @param addInstanceId\r\n   */\n\n\n  BrowserCacheManager.prototype.generateCacheKey = function (key) {\n    var generatedKey = this.validateAndParseJson(key);\n\n    if (!generatedKey) {\n      if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\n        return key;\n      }\n\n      return Constants.CACHE_PREFIX + \".\" + this.clientId + \".\" + key;\n    }\n\n    return JSON.stringify(key);\n  };\n  /**\r\n   * Create authorityKey to cache authority\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.generateAuthorityKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.AUTHORITY + \".\" + stateId);\n  };\n  /**\r\n   * Create Nonce key to cache nonce\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.generateNonceKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN + \".\" + stateId);\n  };\n  /**\r\n   * Creates full cache key for the request state\r\n   * @param stateString State string for the request\r\n   */\n\n\n  BrowserCacheManager.prototype.generateStateKey = function (stateString) {\n    // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.REQUEST_STATE + \".\" + stateId);\n  };\n  /**\r\n   * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n   */\n\n\n  BrowserCacheManager.prototype.getCachedAuthority = function (cachedState) {\n    var stateCacheKey = this.generateStateKey(cachedState);\n    var state = this.getTemporaryCache(stateCacheKey);\n\n    if (!state) {\n      return null;\n    }\n\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    return this.getTemporaryCache(authorityCacheKey);\n  };\n  /**\r\n   * Updates account, authority, and state in cache\r\n   * @param serverAuthenticationRequest\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.updateCacheEntries = function (state, nonce, authorityInstance, loginHint, account) {\n    this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\"); // Cache the request state\n\n    var stateCacheKey = this.generateStateKey(state);\n    this.setTemporaryCache(stateCacheKey, state, false); // Cache the nonce\n\n    var nonceCacheKey = this.generateNonceKey(state);\n    this.setTemporaryCache(nonceCacheKey, nonce, false); // Cache authorityKey\n\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n\n    if (account) {\n      var ccsCredential = {\n        credential: account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    } else if (!StringUtils.isEmpty(loginHint)) {\n      var ccsCredential = {\n        credential: loginHint,\n        type: CcsCredentialType.UPN\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    }\n  };\n  /**\r\n   * Reset all temporary cache items\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.resetRequestCache = function (state) {\n    var _this = this;\n\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\"); // check state and remove associated cache items\n\n    if (!StringUtils.isEmpty(state)) {\n      this.getKeys().forEach(function (key) {\n        if (key.indexOf(state) !== -1) {\n          _this.removeItem(key);\n        }\n      });\n    } // delete generic interactive request parameters\n\n\n    if (state) {\n      this.removeItem(this.generateStateKey(state));\n      this.removeItem(this.generateNonceKey(state));\n      this.removeItem(this.generateAuthorityKey(state));\n    }\n\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n    this.setInteractionInProgress(false);\n  };\n  /**\r\n   * Removes temporary cache for the provided state\r\n   * @param stateString\r\n   */\n\n\n  BrowserCacheManager.prototype.cleanRequestByState = function (stateString) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\"); // Interaction is completed - remove interaction status.\n\n    if (stateString) {\n      var stateKey = this.generateStateKey(stateString);\n      var cachedState = this.temporaryCacheStorage.getItem(stateKey);\n      this.logger.infoPii(\"BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: \" + cachedState);\n      this.resetRequestCache(cachedState || \"\");\n    }\n\n    this.clearMsalCookies();\n  };\n  /**\r\n   * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n   * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n   * @param interactionType\r\n   */\n\n\n  BrowserCacheManager.prototype.cleanRequestByInteractionType = function (interactionType) {\n    var _this = this;\n\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\"); // Loop through all keys to find state key\n\n    this.getKeys().forEach(function (key) {\n      // If this key is not the state key, move on\n      if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n        return;\n      } // Retrieve state value, return if not a valid value\n\n\n      var stateValue = _this.temporaryCacheStorage.getItem(key);\n\n      if (!stateValue) {\n        return;\n      } // Extract state and ensure it matches given InteractionType, then clean request cache\n\n\n      var parsedState = BrowserProtocolUtils.extractBrowserRequestState(_this.cryptoImpl, stateValue);\n\n      if (parsedState && parsedState.interactionType === interactionType) {\n        _this.logger.infoPii(\"BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: \" + stateValue);\n\n        _this.resetRequestCache(stateValue);\n      }\n    });\n    this.clearMsalCookies();\n    this.setInteractionInProgress(false);\n  };\n\n  BrowserCacheManager.prototype.cacheCodeRequest = function (authCodeRequest, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n    var encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n  };\n  /**\r\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n   */\n\n\n  BrowserCacheManager.prototype.getCachedRequest = function (state, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\"); // Get token request from cache and parse as TokenExchangeParameters.\n\n    var encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n\n    if (!encodedTokenRequest) {\n      throw BrowserAuthError.createNoTokenRequestCacheError();\n    }\n\n    var parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest));\n\n    if (!parsedRequest) {\n      throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\n    }\n\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)); // Get cached authority and use if no authority is cached with request.\n\n    if (StringUtils.isEmpty(parsedRequest.authority)) {\n      var authorityCacheKey = this.generateAuthorityKey(state);\n      var cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n\n      if (!cachedAuthority) {\n        throw BrowserAuthError.createNoCachedAuthorityError();\n      }\n\n      parsedRequest.authority = cachedAuthority;\n    }\n\n    return parsedRequest;\n  };\n\n  BrowserCacheManager.prototype.isInteractionInProgress = function (matchClientId) {\n    var clientId = this.getInteractionInProgress();\n\n    if (matchClientId) {\n      return clientId === this.clientId;\n    } else {\n      return !!clientId;\n    }\n  };\n\n  BrowserCacheManager.prototype.getInteractionInProgress = function () {\n    var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\n    return this.getTemporaryCache(key, false);\n  };\n\n  BrowserCacheManager.prototype.setInteractionInProgress = function (inProgress) {\n    // Ensure we don't overwrite interaction in progress for a different clientId\n    var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\n\n    if (inProgress) {\n      if (this.getInteractionInProgress()) {\n        throw BrowserAuthError.createInteractionInProgressError();\n      } else {\n        // No interaction is in progress\n        this.setTemporaryCache(key, this.clientId, false);\n      }\n    } else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\n      this.removeItem(key);\n    }\n  };\n  /**\r\n   * Returns username retrieved from ADAL or MSAL v1 idToken\r\n   */\n\n\n  BrowserCacheManager.prototype.getLegacyLoginHint = function () {\n    // Only check for adal/msal token if no SSO params are being used\n    var adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\n\n    if (adalIdTokenString) {\n      this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n      this.logger.verbose(\"Cached ADAL id token retrieved.\");\n    } // Check for cached MSAL v1 id token\n\n\n    var msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\n\n    if (msalIdTokenString) {\n      this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\n      this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\n    }\n\n    var cachedIdTokenString = msalIdTokenString || adalIdTokenString;\n\n    if (cachedIdTokenString) {\n      var cachedIdToken = new IdToken(cachedIdTokenString, this.cryptoImpl);\n\n      if (cachedIdToken.claims && cachedIdToken.claims.preferred_username) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\n        return cachedIdToken.claims.preferred_username;\n      } else if (cachedIdToken.claims && cachedIdToken.claims.upn) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\n        return cachedIdToken.claims.upn;\n      } else {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\n      }\n    }\n\n    return null;\n  };\n  /**\r\n   * Updates a credential's cache key if the current cache key is outdated\r\n   */\n\n\n  BrowserCacheManager.prototype.updateCredentialCacheKey = function (currentCacheKey, credential) {\n    var updatedCacheKey = credential.generateCredentialKey();\n\n    if (currentCacheKey !== updatedCacheKey) {\n      var cacheItem = this.getItem(currentCacheKey);\n\n      if (cacheItem) {\n        this.removeItem(currentCacheKey);\n        this.setItem(updatedCacheKey, cacheItem);\n        this.logger.verbose(\"Updated an outdated \" + credential.credentialType + \" cache key\");\n        return updatedCacheKey;\n      } else {\n        this.logger.error(\"Attempted to update an outdated \" + credential.credentialType + \" cache key but no item matching the outdated key was found in storage\");\n      }\n    }\n\n    return currentCacheKey;\n  };\n\n  return BrowserCacheManager;\n}(CacheManager);\n\nvar DEFAULT_BROWSER_CACHE_MANAGER = function (clientId, logger) {\n  var cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\n};\n\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"mappings":";;;;;;;;;;AAAA;;;;;AAcA;;;;;;;;;AAKyCA;;AAgBrC,+BAAYC,QAAZ,EAA8BC,WAA9B,EAAmEC,UAAnE,EAAwFC,MAAxF,EAAsG;AAAtG,gBACIC,kBAAMJ,QAAN,EAAgBE,UAAhB,KAA2B,IAD/B,CAAsG;;;AAFnFG,mCAAyB,KAAK,EAAL,GAAU,EAAV,GAAe,IAAxC;AAKfA,SAAI,CAACJ,WAAL,GAAmBA,WAAnB;AACAI,SAAI,CAACF,MAAL,GAAcA,MAAd;AACAE,SAAI,CAACC,eAAL,GAAuB,IAAIC,aAAJ,EAAvB;AACAF,SAAI,CAACG,cAAL,GAAsBH,KAAI,CAACI,mBAAL,CAAyBJ,KAAI,CAACJ,WAAL,CAAiBS,aAA1C,CAAtB;AACAL,SAAI,CAACM,qBAAL,GAA6BN,KAAI,CAACO,0BAAL,CAAgCP,KAAI,CAACJ,WAAL,CAAiBS,aAAjD,CAA7B,CAPkG;;AAUlGL,SAAI,CAACQ,mBAAL;;;AACH;;;;;;;AAMSC,sDAAV,UAA8BJ,aAA9B,EAA0E;AACtE,YAAQA,aAAR;AACI,WAAKK,oBAAoB,CAACC,YAA1B;AACA,WAAKD,oBAAoB,CAACE,cAA1B;AACI,YAAI;;AAEA,iBAAO,IAAIC,cAAJ,CAAmBR,aAAnB,CAAP;AACH,SAHD,CAGE,OAAOS,CAAP,EAAU;AACR,eAAKhB,MAAL,CAAYiB,OAAZ,CAAoBD,CAApB;AACA;AACH;;AATT;;AAcA,SAAKlB,WAAL,CAAiBS,aAAjB,GAAiCK,oBAAoB,CAACR,aAAtD;AACA,WAAO,IAAIA,aAAJ,EAAP;AACH,GAjBS;;;;;;;AAuBAO,6DAAV,UAAqCJ,aAArC,EAAiF;AAC7E,YAAQA,aAAR;AACI,WAAKK,oBAAoB,CAACC,YAA1B;AACA,WAAKD,oBAAoB,CAACE,cAA1B;AACI,YAAI;;AAEA,iBAAO,IAAIC,cAAJ,CAAmBH,oBAAoB,CAACE,cAAxC,CAAP;AACH,SAHD,CAGE,OAAOE,CAAP,EAAU;AACR,eAAKhB,MAAL,CAAYiB,OAAZ,CAAoBD,CAApB;AACA,iBAAO,KAAKb,eAAZ;AACH;;AACL,WAAKS,oBAAoB,CAACR,aAA1B;AACA;AACI,eAAO,KAAKD,eAAZ;AAZR;AAcH,GAfS;;;;;;;AAqBAQ,sDAAV;AAAA;;AACI,QAAMO,UAAU,GAAMC,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0BC,mBAAmB,CAACC,QAApE;AACA,QAAMC,aAAa,GAAMJ,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0BC,mBAAmB,CAACG,WAAvE;AACA,QAAMC,QAAQ,GAAMN,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0BC,mBAAmB,CAACK,KAAlE;AACA,QAAMC,YAAY,GAAMR,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0BC,mBAAmB,CAACO,UAAtE;AAEA,QAAMC,YAAY,GAAG,KAAKxB,cAAL,CAAoByB,OAApB,CAA4BZ,UAA5B,CAArB;AACA,QAAMa,eAAe,GAAG,KAAK1B,cAAL,CAAoByB,OAApB,CAA4BP,aAA5B,CAAxB;AACA,QAAMS,UAAU,GAAG,KAAK3B,cAAL,CAAoByB,OAApB,CAA4BL,QAA5B,CAAnB;AACA,QAAMQ,cAAc,GAAG,KAAK5B,cAAL,CAAoByB,OAApB,CAA4BH,YAA5B,CAAvB;AAEA,QAAMO,MAAM,GAAG,CAACL,YAAD,EAAeE,eAAf,EAAgCC,UAAhC,EAA4CC,cAA5C,CAAf;AACA,QAAME,aAAa,GAAG,CAACd,mBAAmB,CAACC,QAArB,EAA+BD,mBAAmB,CAACG,WAAnD,EAAgEH,mBAAmB,CAACK,KAApF,EAA2FL,mBAAmB,CAACO,UAA/G,CAAtB;AAEAO,iBAAa,CAACC,OAAd,CAAsB,UAACC,QAAD,EAAkBC,KAAlB,EAA+B;AAAK,kBAAI,CAACC,iBAAL,CAAuBF,QAAvB,EAAiCH,MAAM,CAACI,KAAD,CAAvC;AAA+C,KAAzG;AACH,GAfS;;;;;;;;;AAuBA3B,oDAAV,UAA4B6B,MAA5B,EAA4CC,KAA5C,EAA8D;AAC1D,QAAIA,KAAJ,EAAW;AACP,WAAKC,iBAAL,CAAuBF,MAAvB,EAA+BC,KAA/B,EAAsC,IAAtC;AACH;AACJ,GAJS;;;;;;;AAUA9B,uDAAV,UAA+BgC,SAA/B,EAAgD;AAC5C,QAAI;AACA,UAAMC,UAAU,GAAGC,IAAI,CAACC,KAAL,CAAWH,SAAX,CAAnB;;;;;;;;AAOA,aAAQC,UAAU,IAAI,OAAOA,UAAP,KAAsB,QAArC,GAAiDA,UAAjD,GAA8D,IAArE;AACH,KATD,CASE,OAAOG,KAAP,EAAc;AACZ,aAAO,IAAP;AACH;AACJ,GAbS;;;;;;;AAmBVpC,oDAAQqC,GAAR,EAAmB;AACf,WAAO,KAAK3C,cAAL,CAAoByB,OAApB,CAA4BkB,GAA5B,CAAP;AACH,GAFD;;;;;;;;AASArC,oDAAQqC,GAAR,EAAqBP,KAArB,EAAkC;AAC9B,SAAKpC,cAAL,CAAoB4C,OAApB,CAA4BD,GAA5B,EAAiCP,KAAjC;AACH,GAFD;;;;;;;AAQA9B,uDAAWuC,UAAX,EAA6B;AACzB,QAAMC,OAAO,GAAG,KAAKrB,OAAL,CAAaoB,UAAb,CAAhB;;AACA,QAAI,CAACC,OAAL,EAAc;AACV,aAAO,IAAP;AACH;;AAED,QAAMC,aAAa,GAAG,KAAKC,oBAAL,CAA0BF,OAA1B,CAAtB;;AACA,QAAI,CAACC,aAAD,IAAkB,CAACE,aAAa,CAACC,eAAd,CAA8BH,aAA9B,CAAvB,EAAqE;AACjE,aAAO,IAAP;AACH;;AAED,WAAOI,YAAY,CAACC,QAAb,CAAqC,IAAIH,aAAJ,EAArC,EAA0DF,aAA1D,CAAP;AACH,GAZD;;;;;;;;AAmBAzC,uDAAWwC,OAAX,EAAiC;AAC7B,SAAKnD,MAAL,CAAY0D,KAAZ,CAAkB,uCAAlB;AACA,QAAMV,GAAG,GAAGG,OAAO,CAACQ,kBAAR,EAAZ;AACA,SAAKV,OAAL,CAAaD,GAAb,EAAkBH,IAAI,CAACe,SAAL,CAAeT,OAAf,CAAlB;AACH,GAJD;;;;;;;AAUAxC,iEAAqBO,UAArB,EAAuC;AACnC,QAAMuB,KAAK,GAAG,KAAKX,OAAL,CAAaZ,UAAb,CAAd;;AACA,QAAI,CAACuB,KAAL,EAAY;AACR,WAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,gEAAlB;AACA,aAAO,IAAP;AACH;;AAED,QAAMG,aAAa,GAAG,KAAKR,oBAAL,CAA0BZ,KAA1B,CAAtB;;AACA,QAAI,CAACoB,aAAD,IAAkB,CAACC,aAAa,CAACC,eAAd,CAA8BF,aAA9B,CAAvB,EAAqE;AACjE,WAAK7D,MAAL,CAAY0D,KAAZ,CAAkB,gEAAlB;AACA,aAAO,IAAP;AACH;;AAED,SAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,qDAAlB;AACA,WAAOF,YAAY,CAACC,QAAb,CAAsB,IAAIK,aAAJ,EAAtB,EAA2CD,aAA3C,CAAP;AACH,GAfD;;;;;;;AAqBAlD,iEAAqBqD,OAArB,EAA2C;AACvC,SAAKhE,MAAL,CAAY0D,KAAZ,CAAkB,iDAAlB;AACA,QAAMxC,UAAU,GAAG8C,OAAO,CAACC,qBAAR,EAAnB;AACA,SAAKhB,OAAL,CAAa/B,UAAb,EAAyB2B,IAAI,CAACe,SAAL,CAAeI,OAAf,CAAzB;AACH,GAJD;;;;;;;AAUArD,qEAAyBuD,cAAzB,EAA+C;AAC3C,QAAMzB,KAAK,GAAG,KAAKX,OAAL,CAAaoC,cAAb,CAAd;;AACA,QAAI,CAACzB,KAAL,EAAY;AACR,WAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,oEAAlB;AACA,aAAO,IAAP;AACH;;AACD,QAAMS,iBAAiB,GAAG,KAAKd,oBAAL,CAA0BZ,KAA1B,CAA1B;;AACA,QAAI,CAAC0B,iBAAD,IAAsB,CAACC,iBAAiB,CAACC,mBAAlB,CAAsCF,iBAAtC,CAA3B,EAAqF;AACjF,WAAKnE,MAAL,CAAY0D,KAAZ,CAAkB,oEAAlB;AACA,aAAO,IAAP;AACH;;AAED,SAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,yDAAlB;AACA,WAAOF,YAAY,CAACC,QAAb,CAAsB,IAAIW,iBAAJ,EAAtB,EAA+CD,iBAA/C,CAAP;AACH,GAdD;;;;;;;AAoBAxD,qEAAyB2D,WAAzB,EAAuD;AACnD,SAAKtE,MAAL,CAAY0D,KAAZ,CAAkB,qDAAlB;AACA,QAAMQ,cAAc,GAAGI,WAAW,CAACL,qBAAZ,EAAvB;AACA,SAAKhB,OAAL,CAAaiB,cAAb,EAA6BrB,IAAI,CAACe,SAAL,CAAeU,WAAf,CAA7B;AACH,GAJD;;;;;;;AAUA3D,sEAA0B4D,eAA1B,EAAiD;AAC7C,QAAM9B,KAAK,GAAG,KAAKX,OAAL,CAAayC,eAAb,CAAd;;AACA,QAAI,CAAC9B,KAAL,EAAY;AACR,WAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,qEAAlB;AACA,aAAO,IAAP;AACH;;AACD,QAAMc,kBAAkB,GAAG,KAAKnB,oBAAL,CAA0BZ,KAA1B,CAA3B;;AACA,QAAI,CAAC+B,kBAAD,IAAuB,CAACC,kBAAkB,CAACC,oBAAnB,CAAwCF,kBAAxC,CAA5B,EAAyF;AACrF,WAAKxE,MAAL,CAAY0D,KAAZ,CAAkB,qEAAlB;AACA,aAAO,IAAP;AACH;;AAED,SAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,0DAAlB;AACA,WAAOF,YAAY,CAACC,QAAb,CAAsB,IAAIgB,kBAAJ,EAAtB,EAAgDD,kBAAhD,CAAP;AACH,GAdD;;;;;;;AAoBA7D,sEAA0BgE,YAA1B,EAA0D;AACtD,SAAK3E,MAAL,CAAY0D,KAAZ,CAAkB,sDAAlB;AACA,QAAMa,eAAe,GAAGI,YAAY,CAACV,qBAAb,EAAxB;AACA,SAAKhB,OAAL,CAAasB,eAAb,EAA8B1B,IAAI,CAACe,SAAL,CAAee,YAAf,CAA9B;AACH,GAJD;;;;;;;AAUAhE,2DAAeiE,cAAf,EAAqC;AACjC,QAAMnC,KAAK,GAAG,KAAKX,OAAL,CAAa8C,cAAb,CAAd;;AACA,QAAI,CAACnC,KAAL,EAAY;AACR,WAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,0DAAlB;AACA,aAAO,IAAP;AACH;;AAED,QAAMmB,cAAc,GAAG,KAAKxB,oBAAL,CAA0BZ,KAA1B,CAAvB;;AACA,QAAI,CAACoC,cAAD,IAAmB,CAACC,iBAAiB,CAACC,mBAAlB,CAAsCH,cAAtC,EAAsDC,cAAtD,CAAxB,EAA+F;AAC3F,WAAK7E,MAAL,CAAY0D,KAAZ,CAAkB,0DAAlB;AACA,aAAO,IAAP;AACH;;AAED,SAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,+CAAlB;AACA,WAAOF,YAAY,CAACC,QAAb,CAAsB,IAAIqB,iBAAJ,EAAtB,EAA+CD,cAA/C,CAAP;AACH,GAfD;;;;;;;AAqBAlE,2DAAeqE,WAAf,EAA6C;AACzC,SAAKhF,MAAL,CAAY0D,KAAZ,CAAkB,2CAAlB;AACA,QAAMkB,cAAc,GAAGI,WAAW,CAACC,sBAAZ,EAAvB;AACA,SAAKhC,OAAL,CAAa2B,cAAb,EAA6B/B,IAAI,CAACe,SAAL,CAAeoB,WAAf,CAA7B;AACH,GAJD;;;;;;;AAUArE,+DAAmBuE,kBAAnB,EAA6C;AACzC,QAAMzC,KAAK,GAAG,KAAKX,OAAL,CAAaoD,kBAAb,CAAd;;AACA,QAAI,CAACzC,KAAL,EAAY;AACR,WAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,8DAAlB;AACA,aAAO,IAAP;AACH;;AACD,QAAMmB,cAAc,GAAG,KAAKxB,oBAAL,CAA0BZ,KAA1B,CAAvB;;AACA,QAAI,CAACoC,cAAD,IAAmB,CAACM,qBAAqB,CAACC,uBAAtB,CAA8CF,kBAA9C,EAAkEL,cAAlE,CAAxB,EAA2G;AACvG,WAAK7E,MAAL,CAAY0D,KAAZ,CAAkB,8DAAlB;AACA,aAAO,IAAP;AACH;;AAED,SAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,mDAAlB;AACA,WAAOF,YAAY,CAACC,QAAb,CAAsB,IAAI0B,qBAAJ,EAAtB,EAAmDN,cAAnD,CAAP;AACH,GAdD;;;;;;;;AAqBAlE,+DAAmBuE,kBAAnB,EAA+CG,eAA/C,EAAqF;AACjF,SAAKrF,MAAL,CAAY0D,KAAZ,CAAkB,+CAAlB;AACA,SAAKT,OAAL,CAAaiC,kBAAb,EAAiCrC,IAAI,CAACe,SAAL,CAAeyB,eAAf,CAAjC;AACH,GAHD;;;;;;AAQA1E,iEAAqBqC,GAArB,EAAgC;AAC5B,QAAMP,KAAK,GAAG,KAAKtC,eAAL,CAAqB2B,OAArB,CAA6BkB,GAA7B,CAAd;;AACA,QAAI,CAACP,KAAL,EAAY;AACR,WAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,gEAAlB;AACA,aAAO,IAAP;AACH;;AACD,QAAMmB,cAAc,GAAG,KAAKxB,oBAAL,CAA0BZ,KAA1B,CAAvB;;AACA,QAAIoC,cAAc,IAAIS,uBAAuB,CAACC,yBAAxB,CAAkDvC,GAAlD,EAAuD6B,cAAvD,CAAtB,EAA8F;AAC1F,WAAK7E,MAAL,CAAY0D,KAAZ,CAAkB,qDAAlB;AACA,aAAOF,YAAY,CAACC,QAAb,CAAsB,IAAI6B,uBAAJ,EAAtB,EAAqDT,cAArD,CAAP;AACH;;AACD,WAAO,IAAP;AACH,GAZD;;;;;;AAiBAlE;AAAA;;AACI,QAAM6E,OAAO,GAAG,KAAKrF,eAAL,CAAqBsF,OAArB,EAAhB;AACA,WAAOD,OAAO,CAACE,MAAR,CAAe,UAAC1C,GAAD,EAAI;AACtB,aAAO9C,KAAI,CAACyF,mBAAL,CAAyB3C,GAAzB,CAAP;AACH,KAFM,CAAP;AAGH,GALD;;;;;;;;AAYArC,+DAAmBiF,UAAnB,EAAuCC,cAAvC,EAA6D;AACzD,SAAK1F,eAAL,CAAqB8C,OAArB,CAA6B6C,iBAAiB,CAACC,WAA/C,EAA4DH,UAA5D;AACA,SAAKzF,eAAL,CAAqB8C,OAArB,CAA6B6C,iBAAiB,CAACE,WAA/C,EAA4DH,cAA5D;AACH,GAHD;;;;;;AAQAlF;AACI,QAAMsF,GAAG,GAAG,KAAK9F,eAAL,CAAqB2B,OAArB,CAA6BgE,iBAAiB,CAACC,WAA/C,KAA+D,EAA3E;AACA,QAAMG,OAAO,GAAG,KAAK/F,eAAL,CAAqB2B,OAArB,CAA6BgE,iBAAiB,CAACE,WAA/C,KAA+D,EAA/E;AACA,WAAO,CAACC,GAAD,EAAMC,OAAN,CAAP;AACH,GAJD;;;;;;;AAUAvF,iEAAqBqC,GAArB,EAAkCmD,MAAlC,EAAiE;AAC7D,SAAKnG,MAAL,CAAY0D,KAAZ,CAAkB,iDAAlB;AACA,SAAKvD,eAAL,CAAqB8C,OAArB,CAA6BD,GAA7B,EAAkCH,IAAI,CAACe,SAAL,CAAeuC,MAAf,CAAlC;AACH,GAHD;;;;;;AAQAxF;AACI,QAAMyF,kBAAkB,GAAG,KAAKC,gBAAL,CAAsBhF,mBAAmB,CAACiF,cAA1C,CAA3B;AACA,QAAMC,eAAe,GAAG,KAAKlG,cAAL,CAAoByB,OAApB,CAA4BsE,kBAA5B,CAAxB;;AACA,QAAI,CAACG,eAAL,EAAsB;AAClB,aAAO,IAAP;AACH;;AACD,WAAO,KAAKC,sBAAL,CAA4B;AAACC,oBAAc,EAAEF;AAAjB,KAA5B,EAA+D,CAA/D,KAAqE,IAA5E;AACH,GAPD;;;;;;;AAaA5F,6DAAiBwC,OAAjB,EAA4C;AACxC,QAAMiD,kBAAkB,GAAG,KAAKC,gBAAL,CAAsBhF,mBAAmB,CAACiF,cAA1C,CAA3B;;AACA,QAAInD,OAAJ,EAAa;AACT,WAAKnD,MAAL,CAAYiB,OAAZ,CAAoB,sCAApB;AACA,WAAKZ,cAAL,CAAoB4C,OAApB,CAA4BmD,kBAA5B,EAAgDjD,OAAO,CAACsD,cAAxD;AACH,KAHD,MAGO;AACH,WAAKzG,MAAL,CAAYiB,OAAZ,CAAoB,6DAApB;AACA,WAAKZ,cAAL,CAAoBqG,UAApB,CAA+BN,kBAA/B;AACH;AACJ,GATD;;;;;;;AAeAzF,mEAAuBgG,aAAvB,EAAwF;AACpF,QAAMC,WAAW,GAAG,KAAKC,cAAL,EAApB;AACA,WAAOD,WAAW,CAAClB,MAAZ,CAAmB,UAACoB,UAAD,EAAW;AACjC,UAAIH,aAAa,CAACI,QAAd,IAA0BJ,aAAa,CAACI,QAAd,CAAuBC,WAAvB,OAAyCF,UAAU,CAACC,QAAX,CAAoBC,WAApB,EAAvE,EAA0G;AACtG,eAAO,KAAP;AACH;;AAED,UAAIL,aAAa,CAACM,aAAd,IAA+BN,aAAa,CAACM,aAAd,KAAgCH,UAAU,CAACG,aAA9E,EAA6F;AACzF,eAAO,KAAP;AACH;;AAED,UAAIN,aAAa,CAACF,cAAd,IAAgCE,aAAa,CAACF,cAAd,KAAiCK,UAAU,CAACL,cAAhF,EAAgG;AAC5F,eAAO,KAAP;AACH;;AAED,UAAIE,aAAa,CAACO,QAAd,IAA0BP,aAAa,CAACO,QAAd,KAA2BJ,UAAU,CAACI,QAApE,EAA8E;AAC1E,eAAO,KAAP;AACH;;AAED,UAAIP,aAAa,CAACQ,WAAd,IAA6BR,aAAa,CAACQ,WAAd,KAA8BL,UAAU,CAACK,WAA1E,EAAuF;AACnF,eAAO,KAAP;AACH;;AAED,aAAO,IAAP;AACH,KAtBM,CAAP;AAuBH,GAzBD;;;;;;;AA+BAxG,+DAAmByG,kBAAnB,EAA6C;AACzC,QAAM3E,KAAK,GAAG,KAAKX,OAAL,CAAasF,kBAAb,CAAd;;AACA,QAAI,CAAC3E,KAAL,EAAY;AACR,WAAKzC,MAAL,CAAY0D,KAAZ,CAAkB,8DAAlB;AACA,aAAO,IAAP;AACH;;AAED,QAAM2D,qBAAqB,GAAG,KAAKhE,oBAAL,CAA0BZ,KAA1B,CAA9B;;AACA,QAAI,CAAC4E,qBAAD,IAA0B,CAACC,gBAAgB,CAACC,kBAAjB,CAAoCH,kBAApC,EAAwDC,qBAAxD,CAA/B,EAA+G;AAC3G,WAAKrH,MAAL,CAAY0D,KAAZ,CAAkB,8DAAlB;AACA,aAAO,IAAP;AACH;;AAED,SAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,mDAAlB;AACA,WAAOF,YAAY,CAACC,QAAb,CAAsB,IAAI6D,gBAAJ,EAAtB,EAA8CD,qBAA9C,CAAP;AACH,GAfD;;;;;;;;AAsBA1G,+DAAmByG,kBAAnB,EAA+CI,eAA/C,EAAgF;AAC5E,SAAKxH,MAAL,CAAY0D,KAAZ,CAAkB,+CAAlB;AACA,SAAKT,OAAL,CAAamE,kBAAb,EAAiCvE,IAAI,CAACe,SAAL,CAAe4D,eAAf,CAAjC;AACH,GAHD;;;;;;;;AAUA7G,8DAAkB0B,QAAlB,EAAoCoF,WAApC,EAAyD;AACrD,QAAMzE,GAAG,GAAGyE,WAAW,GAAG,KAAKpB,gBAAL,CAAsBhE,QAAtB,CAAH,GAAqCA,QAA5D;;AACA,QAAI,KAAKvC,WAAL,CAAiB4H,sBAArB,EAA6C;AACzC,UAAMC,UAAU,GAAG,KAAKC,aAAL,CAAmB5E,GAAnB,CAAnB;;AACA,UAAI2E,UAAJ,EAAgB;AACZ,aAAK3H,MAAL,CAAY0D,KAAZ,CAAkB,qGAAlB;AACA,eAAOiE,UAAP;AACH;AACJ;;AAED,QAAMlF,KAAK,GAAG,KAAKjC,qBAAL,CAA2BsB,OAA3B,CAAmCkB,GAAnC,CAAd;;AACA,QAAI,CAACP,KAAL,EAAY;;AAER,UAAI,KAAK3C,WAAL,CAAiBS,aAAjB,KAAmCK,oBAAoB,CAACC,YAA5D,EAA0E;AACtE,YAAMgH,IAAI,GAAG,KAAKxH,cAAL,CAAoByB,OAApB,CAA4BkB,GAA5B,CAAb;;AACA,YAAI6E,IAAJ,EAAU;AACN,eAAK7H,MAAL,CAAY0D,KAAZ,CAAkB,oFAAlB;AACA,iBAAOmE,IAAP;AACH;AACJ;;AACD,WAAK7H,MAAL,CAAY0D,KAAZ,CAAkB,6EAAlB;AACA,aAAO,IAAP;AACH;;AACD,SAAK1D,MAAL,CAAY0D,KAAZ,CAAkB,sEAAlB;AACA,WAAOjB,KAAP;AACH,GAzBD;;;;;;;;;;AAkCA9B,8DAAkB0B,QAAlB,EAAoCI,KAApC,EAAmDgF,WAAnD,EAAwE;AACpE,QAAMzE,GAAG,GAAGyE,WAAW,GAAG,KAAKpB,gBAAL,CAAsBhE,QAAtB,CAAH,GAAqCA,QAA5D;AAEA,SAAK7B,qBAAL,CAA2ByC,OAA3B,CAAmCD,GAAnC,EAAwCP,KAAxC;;AACA,QAAI,KAAK3C,WAAL,CAAiB4H,sBAArB,EAA6C;AACzC,WAAK1H,MAAL,CAAY0D,KAAZ,CAAkB,gGAAlB;AACA,WAAKoE,aAAL,CAAmB9E,GAAnB,EAAwBP,KAAxB;AACH;AACJ,GARD;;;;;;;;AAeA9B,uDAAWqC,GAAX,EAAsB;AAClB,SAAK3C,cAAL,CAAoBqG,UAApB,CAA+B1D,GAA/B;AACA,SAAKxC,qBAAL,CAA2BkG,UAA3B,CAAsC1D,GAAtC;;AACA,QAAI,KAAKlD,WAAL,CAAiB4H,sBAArB,EAA6C;AACzC,WAAK1H,MAAL,CAAY0D,KAAZ,CAAkB,sFAAlB;AACA,WAAKqE,eAAL,CAAqB/E,GAArB;AACH;;AACD,WAAO,IAAP;AACH,GARD;;;;;;;AAcArC,wDAAYqC,GAAZ,EAAuB;AACnB,WAAO,KAAK3C,cAAL,CAAoB2H,WAApB,CAAgChF,GAAhC,KAAwC,KAAKxC,qBAAL,CAA2BwH,WAA3B,CAAuChF,GAAvC,CAA/C;AACH,GAFD;;;;;;AAOArC;AACI,oBACO,KAAKN,cAAL,CAAoBoF,OAApB,EADP,EAEO,KAAKjF,qBAAL,CAA2BiF,OAA3B,EAFP;AAIH,GALD;;;;;;AAUM9E,wCAAN;;;;;;;;AAEI;AAAA;AAAA,cAAM,KAAKsH,iBAAL,EAAN;;;;AAAAC;;AACA,iBAAKC,iBAAL;;AAGA,iBAAK1C,OAAL,GAAerD,OAAf,CAAuB,UAACC,QAAD,EAAiB;;AAEpC,kBAAI,CAACnC,KAAI,CAACG,cAAL,CAAoB2H,WAApB,CAAgC3F,QAAhC,KAA6CnC,KAAI,CAACM,qBAAL,CAA2BwH,WAA3B,CAAuC3F,QAAvC,CAA9C,MAAqGA,QAAQ,CAAC+F,OAAT,CAAiBjH,SAAS,CAACC,YAA3B,MAA6C,CAAC,CAA/C,IAAsDiB,QAAQ,CAAC+F,OAAT,CAAiBlI,KAAI,CAACL,QAAtB,MAAoC,CAAC,CAA/L,CAAJ,EAAwM;AACpMK,qBAAI,CAACwG,UAAL,CAAgBrE,QAAhB;AACH;AACJ,aALD;AAOA,iBAAKlC,eAAL,CAAqBkI,KAArB;;;;;;;AACH,GAdK;;;;;;;;;AAsBN1H,0DAAc2H,UAAd,EAAkCC,WAAlC,EAAuDC,OAAvD,EAAuE;AACnE,QAAIC,SAAS,GAAMC,kBAAkB,CAACJ,UAAD,CAAlB,GAA8B,GAA9B,GAAkCI,kBAAkB,CAACH,WAAD,CAApD,GAAiE,UAApF;;AACA,QAAIC,OAAJ,EAAa;AACT,UAAMG,UAAU,GAAG,KAAKC,uBAAL,CAA6BJ,OAA7B,CAAnB;AACAC,eAAS,IAAI,aAAWE,UAAX,GAAqB,GAAlC;AACH;;AAED,QAAI,KAAK7I,WAAL,CAAiB+I,aAArB,EAAoC;AAChCJ,eAAS,IAAI,SAAb;AACH;;AAEDK,YAAQ,CAACC,MAAT,GAAkBN,SAAlB;AACH,GAZD;;;;;;;AAkBA9H,0DAAc2H,UAAd,EAAgC;AAC5B,QAAMU,IAAI,GAAMN,kBAAkB,CAACJ,UAAD,CAAlB,GAA8B,GAA9C;AACA,QAAMW,UAAU,GAAGH,QAAQ,CAACC,MAAT,CAAgBG,KAAhB,CAAsB,GAAtB,CAAnB;;AACA,SAAK,IAAIC,CAAC,GAAW,CAArB,EAAwBA,CAAC,GAAGF,UAAU,CAACG,MAAvC,EAA+CD,CAAC,EAAhD,EAAoD;AAChD,UAAIJ,MAAM,GAAGE,UAAU,CAACE,CAAD,CAAvB;;AACA,aAAOJ,MAAM,CAACM,MAAP,CAAc,CAAd,MAAqB,GAA5B,EAAiC;AAC7BN,cAAM,GAAGA,MAAM,CAACO,SAAP,CAAiB,CAAjB,CAAT;AACH;;AACD,UAAIP,MAAM,CAACX,OAAP,CAAeY,IAAf,MAAyB,CAA7B,EAAgC;AAC5B,eAAOO,kBAAkB,CAACR,MAAM,CAACO,SAAP,CAAiBN,IAAI,CAACI,MAAtB,EAA8BL,MAAM,CAACK,MAArC,CAAD,CAAzB;AACH;AACJ;;AACD,WAAO,EAAP;AACH,GAbD;;;;;;AAkBAzI;AAAA;;AACI,QAAM6I,YAAY,GAAMrI,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0B,KAAKvB,QAAvD;AACA,QAAMoJ,UAAU,GAAGH,QAAQ,CAACC,MAAT,CAAgBG,KAAhB,CAAsB,GAAtB,CAAnB;AACAD,cAAU,CAAC7G,OAAX,CAAmB,UAAC2G,MAAD,EAAe;AAC9B,aAAOA,MAAM,CAACM,MAAP,CAAc,CAAd,MAAqB,GAA5B,EAAiC;;AAE7BN,cAAM,GAAGA,MAAM,CAACO,SAAP,CAAiB,CAAjB,CAAT;AACH;;AACD,UAAIP,MAAM,CAACX,OAAP,CAAeoB,YAAf,MAAiC,CAArC,EAAwC;AACpC,YAAMC,SAAS,GAAGV,MAAM,CAACG,KAAP,CAAa,GAAb,EAAkB,CAAlB,CAAlB;;AACAhJ,aAAI,CAAC6H,eAAL,CAAqB0B,SAArB;AACH;AACJ,KATD;AAUH,GAbD;;;;;;;AAmBA9I,4DAAgB2H,UAAhB,EAAkC;AAC9B,SAAKR,aAAL,CAAmBQ,UAAnB,EAA+B,EAA/B,EAAmC,CAAC,CAApC;AACH,GAFD;;;;;;;AAQA3H,oEAAwB+I,cAAxB,EAA8C;AAC1C,QAAMC,KAAK,GAAG,IAAIC,IAAJ,EAAd;AACA,QAAMC,IAAI,GAAG,IAAID,IAAJ,CAASD,KAAK,CAACG,OAAN,KAAkBJ,cAAc,GAAG,KAAKK,sBAAjD,CAAb;AACA,WAAOF,IAAI,CAACG,WAAL,EAAP;AACH,GAJD;;;;;;AASArJ;AACI,WAAO,KAAKN,cAAZ;AACH,GAFD;;;;;;AAOAM;AAEC,GAFD;;;;;;;;AASAA,6DAAiBqC,GAAjB,EAA4B;AACxB,QAAMiH,YAAY,GAAG,KAAK5G,oBAAL,CAA0BL,GAA1B,CAArB;;AACA,QAAI,CAACiH,YAAL,EAAmB;AACf,UAAIC,WAAW,CAACC,UAAZ,CAAuBnH,GAAvB,EAA4B7B,SAAS,CAACC,YAAtC,KAAuD8I,WAAW,CAACC,UAAZ,CAAuBnH,GAAvB,EAA4B3B,mBAAmB,CAAC+I,aAAhD,CAA3D,EAA2H;AACvH,eAAOpH,GAAP;AACH;;AACD,aAAU7B,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0B,KAAKvB,QAA/B,GAAuC,GAAvC,GAA2CmD,GAArD;AACH;;AAED,WAAOH,IAAI,CAACe,SAAL,CAAeZ,GAAf,CAAP;AACH,GAVD;;;;;;;AAgBArC,iEAAqB0J,WAArB,EAAwC;AAG5B,QAAIC,OAAO,GAEfC,aAAa,CAACC,iBAAd,CAAgC,KAAKzK,UAArC,EAAiDsK,WAAjD,EAA6DI,YAA7D,CAA6DC,EAFzD;AAIR,WAAO,KAAKrE,gBAAL,CAAyBsE,kBAAkB,CAACC,SAAnB,GAA4B,GAA5B,GAAgCN,OAAzD,CAAP;AACH,GARD;;;;;;;AAcA3J,6DAAiB0J,WAAjB,EAAoC;AAGxB,QAAIC,OAAO,GAEfC,aAAa,CAACC,iBAAd,CAAgC,KAAKzK,UAArC,EAAiDsK,WAAjD,EAA6DI,YAA7D,CAA6DC,EAFzD;AAIR,WAAO,KAAKrE,gBAAL,CAAyBsE,kBAAkB,CAACE,aAAnB,GAAgC,GAAhC,GAAoCP,OAA7D,CAAP;AACH,GARD;;;;;;;AAcA3J,6DAAiB0J,WAAjB,EAAoC;;AAIxB,QAAIC,OAAO,GAEfC,aAAa,CAACC,iBAAd,CAAgC,KAAKzK,UAArC,EAAiDsK,WAAjD,EAA6DI,YAA7D,CAA6DC,EAFzD;AAGR,WAAO,KAAKrE,gBAAL,CAAyBsE,kBAAkB,CAACG,aAAnB,GAAgC,GAAhC,GAAoCR,OAA7D,CAAP;AACH,GARD;;;;;;AAaA3J,+DAAmBoK,WAAnB,EAAsC;AAClC,QAAMC,aAAa,GAAG,KAAKC,gBAAL,CAAsBF,WAAtB,CAAtB;AACA,QAAMG,KAAK,GAAG,KAAKC,iBAAL,CAAuBH,aAAvB,CAAd;;AACA,QAAI,CAACE,KAAL,EAAY;AACR,aAAO,IAAP;AACH;;AAED,QAAME,iBAAiB,GAAG,KAAKC,oBAAL,CAA0BH,KAA1B,CAA1B;AACA,WAAO,KAAKC,iBAAL,CAAuBC,iBAAvB,CAAP;AACH,GATD;;;;;;;;AAgBAzK,+DAAmBuK,KAAnB,EAAkCI,KAAlC,EAAiDC,iBAAjD,EAA4EC,SAA5E,EAA+FrI,OAA/F,EAAwH;AACpH,SAAKnD,MAAL,CAAY0D,KAAZ,CAAkB,+CAAlB,EADoH;;AAGpH,QAAMsH,aAAa,GAAG,KAAKC,gBAAL,CAAsBC,KAAtB,CAAtB;AACA,SAAKxI,iBAAL,CAAuBsI,aAAvB,EAAsCE,KAAtC,EAA6C,KAA7C,EAJoH;;AAOpH,QAAMO,aAAa,GAAG,KAAKC,gBAAL,CAAsBR,KAAtB,CAAtB;AACA,SAAKxI,iBAAL,CAAuB+I,aAAvB,EAAsCH,KAAtC,EAA6C,KAA7C,EARoH;;AAWpH,QAAMF,iBAAiB,GAAG,KAAKC,oBAAL,CAA0BH,KAA1B,CAA1B;AACA,SAAKxI,iBAAL,CAAuB0I,iBAAvB,EAA0CG,iBAA1C,EAA6D,KAA7D;;AAEA,QAAIpI,OAAJ,EAAa;AACT,UAAMwI,aAAa,GAAkB;AACjCC,kBAAU,EAAEzI,OAAO,CAAC8D,aADa;AAEjC4E,YAAI,EAAEC,iBAAiB,CAACC;AAFS,OAArC;AAIA,WAAKrJ,iBAAL,CAAuBiI,kBAAkB,CAACqB,cAA1C,EAA0DnJ,IAAI,CAACe,SAAL,CAAe+H,aAAf,CAA1D,EAAyF,IAAzF;AACH,KAND,MAMO,IAAI,CAACzB,WAAW,CAAC+B,OAAZ,CAAoBT,SAApB,CAAL,EAAqC;AACxC,UAAMG,aAAa,GAAkB;AACjCC,kBAAU,EAAEJ,SADqB;AAEjCK,YAAI,EAAEC,iBAAiB,CAACI;AAFS,OAArC;AAIA,WAAKxJ,iBAAL,CAAuBiI,kBAAkB,CAACqB,cAA1C,EAA0DnJ,IAAI,CAACe,SAAL,CAAe+H,aAAf,CAA1D,EAAyF,IAAzF;AACH;AACJ,GA3BD;;;;;;;AAiCAhL,8DAAkBuK,KAAlB,EAA+B;AAA/B;;AACI,SAAKlL,MAAL,CAAY0D,KAAZ,CAAkB,8CAAlB,EAD2B;;AAG3B,QAAI,CAACwG,WAAW,CAAC+B,OAAZ,CAAoBf,KAApB,CAAL,EAAiC;AAC7B,WAAKzF,OAAL,GAAerD,OAAf,CAAuB,eAAG;AACtB,YAAIY,GAAG,CAACoF,OAAJ,CAAY8C,KAAZ,MAAuB,CAAC,CAA5B,EAA+B;AAC3BhL,eAAI,CAACwG,UAAL,CAAgB1D,GAAhB;AACH;AACJ,OAJD;AAKH,KAT0B;;;AAY3B,QAAIkI,KAAJ,EAAW;AACP,WAAKxE,UAAL,CAAgB,KAAKuE,gBAAL,CAAsBC,KAAtB,CAAhB;AACA,WAAKxE,UAAL,CAAgB,KAAKgF,gBAAL,CAAsBR,KAAtB,CAAhB;AACA,WAAKxE,UAAL,CAAgB,KAAK2E,oBAAL,CAA0BH,KAA1B,CAAhB;AACH;;AACD,SAAKxE,UAAL,CAAgB,KAAKL,gBAAL,CAAsBsE,kBAAkB,CAACwB,cAAzC,CAAhB;AACA,SAAKzF,UAAL,CAAgB,KAAKL,gBAAL,CAAsBsE,kBAAkB,CAACyB,UAAzC,CAAhB;AACA,SAAK1F,UAAL,CAAgB,KAAKL,gBAAL,CAAsBsE,kBAAkB,CAAC0B,QAAzC,CAAhB;AACA,SAAK3F,UAAL,CAAgB,KAAKL,gBAAL,CAAsBsE,kBAAkB,CAAC2B,cAAzC,CAAhB;AACA,SAAK5F,UAAL,CAAgB,KAAKL,gBAAL,CAAsBsE,kBAAkB,CAACqB,cAAzC,CAAhB;AACA,SAAKO,wBAAL,CAA8B,KAA9B;AACH,GAvBD;;;;;;;AA6BA5L,gEAAoB0J,WAApB,EAAuC;AACnC,SAAKrK,MAAL,CAAY0D,KAAZ,CAAkB,gDAAlB,EADmC;;AAGnC,QAAI2G,WAAJ,EAAiB;AACb,UAAMmC,QAAQ,GAAG,KAAKvB,gBAAL,CAAsBZ,WAAtB,CAAjB;AACA,UAAMU,WAAW,GAAG,KAAKvK,qBAAL,CAA2BsB,OAA3B,CAAmC0K,QAAnC,CAApB;AACA,WAAKxM,MAAL,CAAYyM,OAAZ,CAAoB,wFAAsF1B,WAA1G;AACA,WAAK2B,iBAAL,CAAuB3B,WAAW,IAAI,EAAtC;AACH;;AACD,SAAK4B,gBAAL;AACH,GAVD;;;;;;;;AAiBAhM,0EAA8BiM,eAA9B,EAA8D;AAA9D;;AACI,SAAK5M,MAAL,CAAY0D,KAAZ,CAAkB,0DAAlB,EAD0D;;AAG1D,SAAK+B,OAAL,GAAerD,OAAf,CAAuB,UAACY,GAAD,EAAI;;AAEvB,UAAIA,GAAG,CAACoF,OAAJ,CAAYuC,kBAAkB,CAACG,aAA/B,MAAkD,CAAC,CAAvD,EAA0D;AACtD;AACH,OAJsB;;;AAOvB,UAAM+B,UAAU,GAAG3M,KAAI,CAACM,qBAAL,CAA2BsB,OAA3B,CAAmCkB,GAAnC,CAAnB;;AACA,UAAI,CAAC6J,UAAL,EAAiB;AACb;AACH,OAVsB;;;AAYvB,UAAMC,WAAW,GAAGC,oBAAoB,CAACC,0BAArB,CAAgD9M,KAAI,CAACH,UAArD,EAAiE8M,UAAjE,CAApB;;AACA,UAAIC,WAAW,IAAIA,WAAW,CAACF,eAAZ,KAAgCA,eAAnD,EAAoE;AAChE1M,aAAI,CAACF,MAAL,CAAYyM,OAAZ,CAAoB,kGAAgGI,UAApH;;AACA3M,aAAI,CAACwM,iBAAL,CAAuBG,UAAvB;AACH;AACJ,KAjBD;AAkBA,SAAKF,gBAAL;AACA,SAAKJ,wBAAL,CAA8B,KAA9B;AACH,GAvBD;;AAyBA5L,6DAAiBsM,eAAjB,EAAkEC,aAAlE,EAAwF;AACpF,SAAKlN,MAAL,CAAY0D,KAAZ,CAAkB,6CAAlB;AAEA,QAAMyJ,YAAY,GAAGD,aAAa,CAACE,YAAd,CAA2BvK,IAAI,CAACe,SAAL,CAAeqJ,eAAf,CAA3B,CAArB;AACA,SAAKvK,iBAAL,CAAuBiI,kBAAkB,CAACwB,cAA1C,EAA0DgB,YAA1D,EAAwE,IAAxE;AACH,GALD;;;;;;AAUAxM,6DAAiBuK,KAAjB,EAAgCgC,aAAhC,EAAsD;AAClD,SAAKlN,MAAL,CAAY0D,KAAZ,CAAkB,6CAAlB,EADkD;;AAGlD,QAAM2J,mBAAmB,GAAG,KAAKlC,iBAAL,CAAuBR,kBAAkB,CAACwB,cAA1C,EAA0D,IAA1D,CAA5B;;AACA,QAAI,CAACkB,mBAAL,EAA0B;AACtB,YAAMC,gBAAgB,CAACC,8BAAjB,EAAN;AACH;;AAED,QAAMC,aAAa,GAAG,KAAKnK,oBAAL,CAA0B6J,aAAa,CAACO,YAAd,CAA2BJ,mBAA3B,CAA1B,CAAtB;;AACA,QAAI,CAACG,aAAL,EAAoB;AAChB,YAAMF,gBAAgB,CAACI,yCAAjB,EAAN;AACH;;AACD,SAAKhH,UAAL,CAAgB,KAAKL,gBAAL,CAAsBsE,kBAAkB,CAACwB,cAAzC,CAAhB,EAZkD;;AAelD,QAAIjC,WAAW,CAAC+B,OAAZ,CAAoBuB,aAAa,CAACG,SAAlC,CAAJ,EAAkD;AAC9C,UAAMvC,iBAAiB,GAAW,KAAKC,oBAAL,CAA0BH,KAA1B,CAAlC;AACA,UAAM0C,eAAe,GAAG,KAAKzC,iBAAL,CAAuBC,iBAAvB,CAAxB;;AACA,UAAI,CAACwC,eAAL,EAAsB;AAClB,cAAMN,gBAAgB,CAACO,4BAAjB,EAAN;AACH;;AACDL,mBAAa,CAACG,SAAd,GAA0BC,eAA1B;AACH;;AAED,WAAOJ,aAAP;AACH,GAzBD;;AA2BA7M,oEAAwBmN,aAAxB,EAA+C;AAC3C,QAAMjO,QAAQ,GAAG,KAAKkO,wBAAL,EAAjB;;AAEA,QAAID,aAAJ,EAAmB;AACf,aAAOjO,QAAQ,KAAK,KAAKA,QAAzB;AACH,KAFD,MAEO;AACH,aAAO,CAAC,CAACA,QAAT;AACH;AACJ,GARD;;AAUAc;AACI,QAAMqC,GAAG,GAAM7B,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0BuJ,kBAAkB,CAACqD,sBAA5D;AACA,WAAO,KAAK7C,iBAAL,CAAuBnI,GAAvB,EAA4B,KAA5B,CAAP;AACH,GAHD;;AAKArC,qEAAyBsN,UAAzB,EAA4C;;AAExC,QAAMjL,GAAG,GAAM7B,SAAS,CAACC,YAAV,GAAsB,GAAtB,GAA0BuJ,kBAAkB,CAACqD,sBAA5D;;AACA,QAAIC,UAAJ,EAAgB;AACZ,UAAI,KAAKF,wBAAL,EAAJ,EAAqC;AACjC,cAAMT,gBAAgB,CAACY,gCAAjB,EAAN;AACH,OAFD,MAEO;;AAEH,aAAKxL,iBAAL,CAAuBM,GAAvB,EAA4B,KAAKnD,QAAjC,EAA2C,KAA3C;AACH;AACJ,KAPD,MAOO,IAAI,CAACoO,UAAD,IAAe,KAAKF,wBAAL,OAAoC,KAAKlO,QAA5D,EAAsE;AACzE,WAAK6G,UAAL,CAAgB1D,GAAhB;AACH;AACJ,GAbD;;;;;;AAkBArC;;AAEI,QAAMwN,iBAAiB,GAAG,KAAKhD,iBAAL,CAAuB9J,mBAAmB,CAAC+I,aAA3C,CAA1B;;AACA,QAAI+D,iBAAJ,EAAuB;AACnB,WAAK9N,cAAL,CAAoBqG,UAApB,CAA+BrF,mBAAmB,CAAC+I,aAAnD;AACA,WAAKpK,MAAL,CAAYiB,OAAZ,CAAoB,iCAApB;AACH,KANL;;;AASI,QAAMmN,iBAAiB,GAAG,KAAKjD,iBAAL,CAAuB9J,mBAAmB,CAACC,QAA3C,EAAqD,IAArD,CAA1B;;AACA,QAAI8M,iBAAJ,EAAuB;AACnB,WAAK1H,UAAL,CAAgB,KAAKL,gBAAL,CAAsBhF,mBAAmB,CAACC,QAA1C,CAAhB;AACA,WAAKtB,MAAL,CAAYiB,OAAZ,CAAoB,sCAApB;AACH;;AAED,QAAMoN,mBAAmB,GAAGD,iBAAiB,IAAID,iBAAjD;;AACA,QAAIE,mBAAJ,EAAyB;AACrB,UAAMC,aAAa,GAAG,IAAIC,OAAJ,CAAYF,mBAAZ,EAAiC,KAAKtO,UAAtC,CAAtB;;AACA,UAAIuO,aAAa,CAACE,MAAd,IAAwBF,aAAa,CAACE,MAAd,CAAqBC,kBAAjD,EAAqE;AACjE,aAAKzO,MAAL,CAAYiB,OAAZ,CAAoB,2GAApB;AACA,eAAOqN,aAAa,CAACE,MAAd,CAAqBC,kBAA5B;AACH,OAHD,MAIK,IAAIH,aAAa,CAACE,MAAd,IAAwBF,aAAa,CAACE,MAAd,CAAqBE,GAAjD,EAAsD;AACvD,aAAK1O,MAAL,CAAYiB,OAAZ,CAAoB,4FAApB;AACA,eAAOqN,aAAa,CAACE,MAAd,CAAqBE,GAA5B;AACH,OAHI,MAIA;AACD,aAAK1O,MAAL,CAAYiB,OAAZ,CAAoB,wJAApB;AACH;AACJ;;AAED,WAAO,IAAP;AACH,GAhCD;;;;;;AAqCAN,qEAAyBgO,eAAzB,EAAkD/C,UAAlD,EAAiF;AAC7E,QAAMgD,eAAe,GAAGhD,UAAU,CAAC3H,qBAAX,EAAxB;;AAEA,QAAI0K,eAAe,KAAKC,eAAxB,EAAyC;AACrC,UAAMC,SAAS,GAAG,KAAK/M,OAAL,CAAa6M,eAAb,CAAlB;;AACA,UAAIE,SAAJ,EAAe;AACX,aAAKnI,UAAL,CAAgBiI,eAAhB;AACA,aAAK1L,OAAL,CAAa2L,eAAb,EAA8BC,SAA9B;AACA,aAAK7O,MAAL,CAAYiB,OAAZ,CAAoB,yBAAuB2K,UAAU,CAACkD,cAAlC,GAAgD,YAApE;AACA,eAAOF,eAAP;AACH,OALD,MAKO;AACH,aAAK5O,MAAL,CAAY+C,KAAZ,CAAkB,qCAAmC6I,UAAU,CAACkD,cAA9C,GAA4D,uEAA9E;AACH;AACJ;;AAED,WAAOH,eAAP;AACH,GAhBD;;AAiBJ;AAn8BA,EAAyCnL;;IAq8B5BuL,6BAA6B,GAAG,UAAClP,QAAD,EAAmBG,MAAnB,EAAiC;AAC1E,MAAMgP,YAAY,GAAG;AACjBzO,iBAAa,EAAEK,oBAAoB,CAACR,aADnB;AAEjBsH,0BAAsB,EAAE,KAFP;AAGjBmB,iBAAa,EAAE;AAHE,GAArB;AAKA,SAAO,IAAIlI,mBAAJ,CAAwBd,QAAxB,EAAkCmP,YAAlC,EAAgDC,6BAAhD,EAA+EjP,MAA/E,CAAP;AACJ","names":["__extends","clientId","cacheConfig","cryptoImpl","logger","_super","_this","internalStorage","MemoryStorage","browserStorage","setupBrowserStorage","cacheLocation","temporaryCacheStorage","setupTemporaryCacheStorage","migrateCacheEntries","BrowserCacheManager","BrowserCacheLocation","LocalStorage","SessionStorage","BrowserStorage","e","verbose","idTokenKey","Constants","CACHE_PREFIX","PersistentCacheKeys","ID_TOKEN","clientInfoKey","CLIENT_INFO","errorKey","ERROR","errorDescKey","ERROR_DESC","idTokenValue","getItem","clientInfoValue","errorValue","errorDescValue","values","keysToMigrate","forEach","cacheKey","index","migrateCacheEntry","newKey","value","setTemporaryCache","jsonValue","parsedJson","JSON","parse","error","key","setItem","accountKey","account","parsedAccount","validateAndParseJson","AccountEntity","isAccountEntity","CacheManager","toObject","trace","generateAccountKey","stringify","parsedIdToken","IdTokenEntity","isIdTokenEntity","idToken","generateCredentialKey","accessTokenKey","parsedAccessToken","AccessTokenEntity","isAccessTokenEntity","accessToken","refreshTokenKey","parsedRefreshToken","RefreshTokenEntity","isRefreshTokenEntity","refreshToken","appMetadataKey","parsedMetadata","AppMetadataEntity","isAppMetadataEntity","appMetadata","generateAppMetadataKey","serverTelemetryKey","ServerTelemetryEntity","isServerTelemetryEntity","serverTelemetry","AuthorityMetadataEntity","isAuthorityMetadataEntity","allKeys","getKeys","filter","isAuthorityMetadata","wrapperSKU","wrapperVersion","InMemoryCacheKeys","WRAPPER_SKU","WRAPPER_VER","sku","version","entity","activeAccountIdKey","generateCacheKey","ACTIVE_ACCOUNT","activeAccountId","getAccountInfoByFilter","localAccountId","removeItem","accountFilter","allAccounts","getAllAccounts","accountObj","username","toLowerCase","homeAccountId","tenantId","environment","throttlingCacheKey","parsedThrottlingCache","ThrottlingEntity","isThrottlingEntity","throttlingCache","generateKey","storeAuthStateInCookie","itemCookie","getItemCookie","item","setItemCookie","clearItemCookie","containsKey","removeAllAccounts","_a","removeAppMetadata","indexOf","clear","cookieName","cookieValue","expires","cookieStr","encodeURIComponent","expireTime","getCookieExpirationTime","secureCookies","document","cookie","name","cookieList","split","i","length","charAt","substring","decodeURIComponent","cookiePrefix","cookieKey","cookieLifeDays","today","Date","expr","getTime","COOKIE_LIFE_MULTIPLIER","toUTCString","generatedKey","StringUtils","startsWith","ADAL_ID_TOKEN","stateString","stateId","ProtocolUtils","parseRequestState","libraryState","id","TemporaryCacheKeys","AUTHORITY","NONCE_IDTOKEN","REQUEST_STATE","cachedState","stateCacheKey","generateStateKey","state","getTemporaryCache","authorityCacheKey","generateAuthorityKey","nonce","authorityInstance","loginHint","nonceCacheKey","generateNonceKey","ccsCredential","credential","type","CcsCredentialType","HOME_ACCOUNT_ID","CCS_CREDENTIAL","isEmpty","UPN","REQUEST_PARAMS","ORIGIN_URI","URL_HASH","CORRELATION_ID","setInteractionInProgress","stateKey","infoPii","resetRequestCache","clearMsalCookies","interactionType","stateValue","parsedState","BrowserProtocolUtils","extractBrowserRequestState","authCodeRequest","browserCrypto","encodedValue","base64Encode","encodedTokenRequest","BrowserAuthError","createNoTokenRequestCacheError","parsedRequest","base64Decode","createUnableToParseTokenRequestCacheError","authority","cachedAuthority","createNoCachedAuthorityError","matchClientId","getInteractionInProgress","INTERACTION_STATUS_KEY","inProgress","createInteractionInProgressError","adalIdTokenString","msalIdTokenString","cachedIdTokenString","cachedIdToken","IdToken","claims","preferred_username","upn","currentCacheKey","updatedCacheKey","cacheItem","credentialType","DEFAULT_BROWSER_CACHE_MANAGER","cacheOptions","DEFAULT_CRYPTO_IMPLEMENTATION"],"sources":["C:\\Users\\empti\\OneDrive\\Desktop\\User_Interface\\user_interface_frontend\\node_modules\\@azure\\msal-browser\\src\\cache\\BrowserCacheManager.ts"],"sourcesContent":["/*\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { Constants, PersistentCacheKeys, StringUtils, CommonAuthorizationCodeRequest, ICrypto, AccountEntity, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, CacheManager, ServerTelemetryEntity, ThrottlingEntity, ProtocolUtils, Logger, AuthorityMetadataEntity, DEFAULT_CRYPTO_IMPLEMENTATION, AccountInfo, CcsCredential, CcsCredentialType, IdToken, ValidCredentialType } from \"@azure/msal-common\";\nimport { CacheOptions } from \"../config/Configuration\";\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\nimport { BrowserCacheLocation, InteractionType, TemporaryCacheKeys, InMemoryCacheKeys } from \"../utils/BrowserConstants\";\nimport { BrowserStorage } from \"./BrowserStorage\";\nimport { MemoryStorage } from \"./MemoryStorage\";\nimport { IWindowStorage } from \"./IWindowStorage\";\nimport { BrowserProtocolUtils } from \"../utils/BrowserProtocolUtils\";\n\n/**\n * This class implements the cache storage interface for MSAL through browser local or session storage.\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\n * parameters such as state and nonce, generally.\n */\nexport class BrowserCacheManager extends CacheManager {\n\n    // Cache configuration, either set by user or default values.\n    protected cacheConfig: Required<CacheOptions>;\n    // Window storage object (either local or sessionStorage)\n    protected browserStorage: IWindowStorage<string>;\n    // Internal in-memory storage object used for data used by msal that does not need to persist across page loads\n    protected internalStorage: MemoryStorage<string>;\n    // Temporary cache\n    protected temporaryCacheStorage: IWindowStorage<string>;\n    // Client id of application. Used in cache keys to partition cache correctly in the case of multiple instances of MSAL.\n    protected logger: Logger;\n\n    // Cookie life calculation (hours * minutes * seconds * ms)\n    protected readonly COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\n\n    constructor(clientId: string, cacheConfig: Required<CacheOptions>, cryptoImpl: ICrypto, logger: Logger) {\n        super(clientId, cryptoImpl);\n\n        this.cacheConfig = cacheConfig;\n        this.logger = logger;\n        this.internalStorage = new MemoryStorage();\n        this.browserStorage = this.setupBrowserStorage(this.cacheConfig.cacheLocation);\n        this.temporaryCacheStorage = this.setupTemporaryCacheStorage(this.cacheConfig.cacheLocation);\n\n        // Migrate any cache entries from older versions of MSAL.\n        this.migrateCacheEntries();\n    }\n\n    /**\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\n     * @param cacheLocation\n     */\n    protected setupBrowserStorage(cacheLocation: BrowserCacheLocation | string): IWindowStorage<string> {\n        switch (cacheLocation) {\n            case BrowserCacheLocation.LocalStorage:\n            case BrowserCacheLocation.SessionStorage:\n                try {\n                    // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n                    return new BrowserStorage(cacheLocation);\n                } catch (e) {\n                    this.logger.verbose(e);\n                    break;\n                }\n            case BrowserCacheLocation.MemoryStorage:\n            default:\n                break;\n        }\n        this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n        return new MemoryStorage();\n    }\n\n    /**\n     *\n     * @param cacheLocation\n     */\n    protected setupTemporaryCacheStorage(cacheLocation: BrowserCacheLocation | string): IWindowStorage<string> {\n        switch (cacheLocation) {\n            case BrowserCacheLocation.LocalStorage:\n            case BrowserCacheLocation.SessionStorage:\n                try {\n                    // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n                    return new BrowserStorage(BrowserCacheLocation.SessionStorage);\n                } catch (e) {\n                    this.logger.verbose(e);\n                    return this.internalStorage;\n                }\n            case BrowserCacheLocation.MemoryStorage:\n            default:\n                return this.internalStorage;\n        }\n    }\n\n    /**\n     * Migrate all old cache entries to new schema. No rollback supported.\n     * @param storeAuthStateInCookie\n     */\n    protected migrateCacheEntries(): void {\n        const idTokenKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ID_TOKEN}`;\n        const clientInfoKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.CLIENT_INFO}`;\n        const errorKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR}`;\n        const errorDescKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR_DESC}`;\n\n        const idTokenValue = this.browserStorage.getItem(idTokenKey);\n        const clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n        const errorValue = this.browserStorage.getItem(errorKey);\n        const errorDescValue = this.browserStorage.getItem(errorDescKey);\n\n        const values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n        const keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\n\n        keysToMigrate.forEach((cacheKey:string, index: number) => this.migrateCacheEntry(cacheKey, values[index]));\n    }\n\n    /**\n     * Utility function to help with migration.\n     * @param newKey\n     * @param value\n     * @param storeAuthStateInCookie\n     */\n    protected migrateCacheEntry(newKey: string, value: string|null): void {\n        if (value) {\n            this.setTemporaryCache(newKey, value, true);\n        }\n    }\n\n    /**\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\n     * @param input\n     */\n    protected validateAndParseJson(jsonValue: string): object | null {\n        try {\n            const parsedJson = JSON.parse(jsonValue);\n            /**\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\n             *\n             */\n            return (parsedJson && typeof parsedJson === \"object\") ? parsedJson : null;\n        } catch (error) {\n            return null;\n        }\n    }\n\n    /**\n     * fetches the entry from the browser storage based off the key\n     * @param key\n     */\n    getItem(key: string): string | null {\n        return this.browserStorage.getItem(key);\n    }\n\n    /**\n     * sets the entry in the browser storage\n     * @param key\n     * @param value\n     */\n    setItem(key: string, value: string): void {\n        this.browserStorage.setItem(key, value);\n    }\n\n    /**\n     * fetch the account entity from the platform cache\n     * @param accountKey\n     */\n    getAccount(accountKey: string): AccountEntity | null {\n        const account = this.getItem(accountKey);\n        if (!account) {\n            return null;\n        }\n\n        const parsedAccount = this.validateAndParseJson(account);\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n            return null;\n        }\n\n        return CacheManager.toObject<AccountEntity>(new AccountEntity(), parsedAccount);\n    }\n\n    /**\n     * set account entity in the platform cache\n     * @param key\n     * @param value\n     */\n    setAccount(account: AccountEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\n        const key = account.generateAccountKey();\n        this.setItem(key, JSON.stringify(account));\n    }\n\n    /**\n     * generates idToken entity from a string\n     * @param idTokenKey\n     */\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\n        const value = this.getItem(idTokenKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n            return null;\n        }\n\n        const parsedIdToken = this.validateAndParseJson(value);\n        if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n        return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\n    }\n\n    /**\n     * set IdToken credential to the platform cache\n     * @param idToken\n     */\n    setIdTokenCredential(idToken: IdTokenEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n        const idTokenKey = idToken.generateCredentialKey();\n        this.setItem(idTokenKey, JSON.stringify(idToken));\n    }\n\n    /**\n     * generates accessToken entity from a string\n     * @param key\n     */\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\n        const value = this.getItem(accessTokenKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n            return null;\n        }\n        const parsedAccessToken = this.validateAndParseJson(value);\n        if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n        return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\n    }\n\n    /**\n     * set accessToken credential to the platform cache\n     * @param accessToken\n     */\n    setAccessTokenCredential(accessToken: AccessTokenEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n        const accessTokenKey = accessToken.generateCredentialKey();\n        this.setItem(accessTokenKey, JSON.stringify(accessToken));\n    }\n\n    /**\n     * generates refreshToken entity from a string\n     * @param refreshTokenKey\n     */\n    getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null {\n        const value = this.getItem(refreshTokenKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n            return null;\n        }\n        const parsedRefreshToken = this.validateAndParseJson(value);\n        if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n        return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\n    }\n\n    /**\n     * set refreshToken credential to the platform cache\n     * @param refreshToken\n     */\n    setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n        const refreshTokenKey = refreshToken.generateCredentialKey();\n        this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\n    }\n\n    /**\n     * fetch appMetadata entity from the platform cache\n     * @param appMetadataKey\n     */\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\n        const value = this.getItem(appMetadataKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n            return null;\n        }\n\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n        return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\n    }\n\n    /**\n     * set appMetadata entity to the platform cache\n     * @param appMetadata\n     */\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n        const appMetadataKey = appMetadata.generateAppMetadataKey();\n        this.setItem(appMetadataKey, JSON.stringify(appMetadata));\n    }\n\n    /**\n     * fetch server telemetry entity from the platform cache\n     * @param serverTelemetryKey\n     */\n    getServerTelemetry(serverTelemetryKey: string): ServerTelemetryEntity | null {\n        const value = this.getItem(serverTelemetryKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n            return null;\n        }\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n        return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\n    }\n\n    /**\n     * set server telemetry entity to the platform cache\n     * @param serverTelemetryKey\n     * @param serverTelemetry\n     */\n    setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n        this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadata(key: string) : AuthorityMetadataEntity | null {\n        const value = this.internalStorage.getItem(key);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n            return null;\n        }\n        const parsedMetadata = this.validateAndParseJson(value);\n        if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n            return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\n        }\n        return null;\n    }\n\n    /**\n     *\n     */\n    getAuthorityMetadataKeys(): Array<string> {\n        const allKeys = this.internalStorage.getKeys();\n        return allKeys.filter((key) => {\n            return this.isAuthorityMetadata(key);\n        });\n    }\n\n    /**\n     * Sets wrapper metadata in memory\n     * @param wrapperSKU \n     * @param wrapperVersion \n     */\n    setWrapperMetadata(wrapperSKU: string, wrapperVersion: string): void {\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n    }\n\n    /**\n     * Returns wrapper metadata from in-memory storage\n     */\n    getWrapperMetadata(): [string, string] {\n        const sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || \"\";\n        const version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || \"\";\n        return [sku, version];\n    }\n\n    /**\n     *\n     * @param entity\n     */\n    setAuthorityMetadata(key: string, entity: AuthorityMetadataEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n        this.internalStorage.setItem(key, JSON.stringify(entity));\n    }\n\n    /**\n     * Gets the active account\n     */\n    getActiveAccount(): AccountInfo | null {\n        const activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n        const activeAccountId = this.browserStorage.getItem(activeAccountIdKey);\n        if (!activeAccountId) {\n            return null;\n        }\n        return this.getAccountInfoByFilter({localAccountId: activeAccountId})[0] || null;\n    }\n\n    /**\n     * Sets the active account's localAccountId in cache\n     * @param account \n     */\n    setActiveAccount(account: AccountInfo | null): void {\n        const activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n        if (account) {\n            this.logger.verbose(\"setActiveAccount: Active account set\");\n            this.browserStorage.setItem(activeAccountIdKey, account.localAccountId);\n        } else {\n            this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n            this.browserStorage.removeItem(activeAccountIdKey);\n        }\n    }\n\n    /**\n     * Gets a list of accounts that match all of the filters provided\n     * @param account \n     */\n    getAccountInfoByFilter(accountFilter: Partial<Omit<AccountInfo, \"idTokenClaims\"|\"name\">>): AccountInfo[] {\n        const allAccounts = this.getAllAccounts();\n        return allAccounts.filter((accountObj) => {\n            if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\n                return false;\n            }\n\n            if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\n                return false;\n            }\n\n            if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\n                return false;\n            }\n\n            if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\n                return false;\n            }\n\n            if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\n                return false;\n            }\n            \n            return true;\n        });\n    }\n\n    /**\n     * fetch throttling entity from the platform cache\n     * @param throttlingCacheKey\n     */\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\n        const value = this.getItem(throttlingCacheKey);\n        if (!value) {\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n            return null;\n        }\n\n        const parsedThrottlingCache = this.validateAndParseJson(value);\n        if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n            return null;\n        }\n\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n        return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\n    }\n\n    /**\n     * set throttling entity to the platform cache\n     * @param throttlingCacheKey\n     * @param throttlingCache\n     */\n    setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void {\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n        this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n    }\n\n    /**\n     * Gets cache item with given key.\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    getTemporaryCache(cacheKey: string, generateKey?: boolean): string | null {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            const itemCookie = this.getItemCookie(key);\n            if (itemCookie) {\n                this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n                return itemCookie;\n            }\n        }\n\n        const value = this.temporaryCacheStorage.getItem(key);\n        if (!value) {\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\n            if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n                const item = this.browserStorage.getItem(key);\n                if (item) {\n                    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n                    return item;\n                }\n            }\n            this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n            return null;\n        }\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n        return value;\n    }\n\n    /**\n     * Sets the cache item with the key and value given.\n     * Stores in cookie if storeAuthStateInCookie is set to true.\n     * This can cause cookie overflow if used incorrectly.\n     * @param key\n     * @param value\n     */\n    setTemporaryCache(cacheKey: string, value: string, generateKey?: boolean): void {\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n\n        this.temporaryCacheStorage.setItem(key, value);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n            this.setItemCookie(key, value);\n        }\n    }\n\n    /**\n     * Removes the cache item with the given key.\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\n     * @param key\n     */\n    removeItem(key: string): boolean {\n        this.browserStorage.removeItem(key);\n        this.temporaryCacheStorage.removeItem(key);\n        if (this.cacheConfig.storeAuthStateInCookie) {\n            this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n            this.clearItemCookie(key);\n        }\n        return true;\n    }\n\n    /**\n     * Checks whether key is in cache.\n     * @param key\n     */\n    containsKey(key: string): boolean {\n        return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\n    }\n\n    /**\n     * Gets all keys in window.\n     */\n    getKeys(): string[] {\n        return [\n            ...this.browserStorage.getKeys(),\n            ...this.temporaryCacheStorage.getKeys()\n        ];\n    }\n\n    /**\n     * Clears all cache entries created by MSAL.\n     */\n    async clear(): Promise<void> {\n        // Removes all accounts and their credentials\n        await this.removeAllAccounts();\n        this.removeAppMetadata();\n\n        // Removes all remaining MSAL cache items\n        this.getKeys().forEach((cacheKey: string) => {\n            // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\n            if ((this.browserStorage.containsKey(cacheKey) || this.temporaryCacheStorage.containsKey(cacheKey)) && ((cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1) || (cacheKey.indexOf(this.clientId) !== -1))) {\n                this.removeItem(cacheKey);\n            }\n        });\n\n        this.internalStorage.clear();\n    }\n\n    /**\n     * Add value to cookies\n     * @param cookieName\n     * @param cookieValue\n     * @param expires\n     */\n    setItemCookie(cookieName: string, cookieValue: string, expires?: number): void {\n        let cookieStr = `${encodeURIComponent(cookieName)}=${encodeURIComponent(cookieValue)};path=/;`;\n        if (expires) {\n            const expireTime = this.getCookieExpirationTime(expires);\n            cookieStr += `expires=${expireTime};`;\n        }\n\n        if (this.cacheConfig.secureCookies) {\n            cookieStr += \"Secure;\";\n        }\n        \n        document.cookie = cookieStr;\n    }\n\n    /**\n     * Get one item by key from cookies\n     * @param cookieName\n     */\n    getItemCookie(cookieName: string): string {\n        const name = `${encodeURIComponent(cookieName)}=`;\n        const cookieList = document.cookie.split(\";\");\n        for (let i: number = 0; i < cookieList.length; i++) {\n            let cookie = cookieList[i];\n            while (cookie.charAt(0) === \" \") {\n                cookie = cookie.substring(1);\n            }\n            if (cookie.indexOf(name) === 0) {\n                return decodeURIComponent(cookie.substring(name.length, cookie.length));\n            }\n        }\n        return \"\";\n    }\n\n    /**\n     * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\n     */\n    clearMsalCookies(): void {\n        const cookiePrefix = `${Constants.CACHE_PREFIX}.${this.clientId}`;\n        const cookieList = document.cookie.split(\";\");\n        cookieList.forEach((cookie: string): void => {\n            while (cookie.charAt(0) === \" \") {\n                // eslint-disable-next-line no-param-reassign\n                cookie = cookie.substring(1);\n            }\n            if (cookie.indexOf(cookiePrefix) === 0) {\n                const cookieKey = cookie.split(\"=\")[0];\n                this.clearItemCookie(cookieKey);\n            }\n        });\n    }\n\n    /**\n     * Clear an item in the cookies by key\n     * @param cookieName\n     */\n    clearItemCookie(cookieName: string): void {\n        this.setItemCookie(cookieName, \"\", -1);\n    }\n\n    /**\n     * Get cookie expiration time\n     * @param cookieLifeDays\n     */\n    getCookieExpirationTime(cookieLifeDays: number): string {\n        const today = new Date();\n        const expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\n        return expr.toUTCString();\n    }\n\n    /**\n     * Gets the cache object referenced by the browser\n     */\n    getCache(): object {\n        return this.browserStorage;\n    }\n\n    /**\n     * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\n     */\n    setCache(): void {\n        // sets nothing\n    }\n\n    /**\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\n     * @param key\n     * @param addInstanceId\n     */\n    generateCacheKey(key: string): string {\n        const generatedKey = this.validateAndParseJson(key);\n        if (!generatedKey) {\n            if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\n                return key;\n            }\n            return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\n        }\n\n        return JSON.stringify(key);\n    }\n\n    /**\n     * Create authorityKey to cache authority\n     * @param state\n     */\n    generateAuthorityKey(stateString: string): string {\n        const {\n            libraryState: {\n                id: stateId\n            }\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n\n        return this.generateCacheKey(`${TemporaryCacheKeys.AUTHORITY}.${stateId}`);\n    }\n\n    /**\n     * Create Nonce key to cache nonce\n     * @param state\n     */\n    generateNonceKey(stateString: string): string {\n        const {\n            libraryState: {\n                id: stateId\n            }\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n\n        return this.generateCacheKey(`${TemporaryCacheKeys.NONCE_IDTOKEN}.${stateId}`);\n    }\n\n    /**\n     * Creates full cache key for the request state\n     * @param stateString State string for the request\n     */\n    generateStateKey(stateString: string): string {\n        // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n        const {\n            libraryState: {\n                id: stateId\n            }\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\n        return this.generateCacheKey(`${TemporaryCacheKeys.REQUEST_STATE}.${stateId}`);\n    } \n\n    /**\n     * Gets the cached authority based on the cached state. Returns empty if no cached state found.\n     */\n    getCachedAuthority(cachedState: string): string | null {\n        const stateCacheKey = this.generateStateKey(cachedState);\n        const state = this.getTemporaryCache(stateCacheKey);\n        if (!state) {\n            return null;\n        }\n\n        const authorityCacheKey = this.generateAuthorityKey(state);\n        return this.getTemporaryCache(authorityCacheKey);\n    }\n\n    /**\n     * Updates account, authority, and state in cache\n     * @param serverAuthenticationRequest\n     * @param account\n     */\n    updateCacheEntries(state: string, nonce: string, authorityInstance: string, loginHint: string, account: AccountInfo|null): void {\n        this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\n        // Cache the request state\n        const stateCacheKey = this.generateStateKey(state);\n        this.setTemporaryCache(stateCacheKey, state, false);\n\n        // Cache the nonce\n        const nonceCacheKey = this.generateNonceKey(state);\n        this.setTemporaryCache(nonceCacheKey, nonce, false);\n\n        // Cache authorityKey\n        const authorityCacheKey = this.generateAuthorityKey(state);\n        this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n\n        if (account) {\n            const ccsCredential: CcsCredential = {\n                credential: account.homeAccountId,\n                type: CcsCredentialType.HOME_ACCOUNT_ID\n            };\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n        } else if (!StringUtils.isEmpty(loginHint)) {\n            const ccsCredential: CcsCredential = {\n                credential: loginHint,\n                type: CcsCredentialType.UPN\n            };\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n        }\n    }\n\n    /**\n     * Reset all temporary cache items\n     * @param state\n     */\n    resetRequestCache(state: string): void {\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n        // check state and remove associated cache items\n        if (!StringUtils.isEmpty(state)) {\n            this.getKeys().forEach(key => {\n                if (key.indexOf(state) !== -1) {\n                    this.removeItem(key);\n                }\n            });\n        }\n\n        // delete generic interactive request parameters\n        if (state) {\n            this.removeItem(this.generateStateKey(state));\n            this.removeItem(this.generateNonceKey(state));\n            this.removeItem(this.generateAuthorityKey(state));\n        }\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n        this.setInteractionInProgress(false);\n    }\n\n    /**\n     * Removes temporary cache for the provided state\n     * @param stateString \n     */\n    cleanRequestByState(stateString: string): void {\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\n        // Interaction is completed - remove interaction status.\n        if (stateString) {\n            const stateKey = this.generateStateKey(stateString);\n            const cachedState = this.temporaryCacheStorage.getItem(stateKey);\n            this.logger.infoPii(`BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: ${cachedState}`);\n            this.resetRequestCache(cachedState || \"\");\n        }\n        this.clearMsalCookies();\n    }\n\n    /**\n     * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\n     * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\n     * @param interactionType \n     */\n    cleanRequestByInteractionType(interactionType: InteractionType): void {\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\n        // Loop through all keys to find state key\n        this.getKeys().forEach((key) => {\n            // If this key is not the state key, move on\n            if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n                return;\n            }\n            \n            // Retrieve state value, return if not a valid value\n            const stateValue = this.temporaryCacheStorage.getItem(key);\n            if (!stateValue) {\n                return;\n            }\n            // Extract state and ensure it matches given InteractionType, then clean request cache\n            const parsedState = BrowserProtocolUtils.extractBrowserRequestState(this.cryptoImpl, stateValue);\n            if (parsedState && parsedState.interactionType === interactionType) {\n                this.logger.infoPii(`BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: ${stateValue}`);\n                this.resetRequestCache(stateValue);\n            }\n        });\n        this.clearMsalCookies();\n        this.setInteractionInProgress(false);\n    }\n\n    cacheCodeRequest(authCodeRequest: CommonAuthorizationCodeRequest, browserCrypto: ICrypto): void {\n        this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n\n        const encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\n        this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n    }\n\n    /**\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\n     */\n    getCachedRequest(state: string, browserCrypto: ICrypto): CommonAuthorizationCodeRequest {\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n        // Get token request from cache and parse as TokenExchangeParameters.\n        const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n        if (!encodedTokenRequest) {\n            throw BrowserAuthError.createNoTokenRequestCacheError();\n        }\n\n        const parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest)) as CommonAuthorizationCodeRequest;\n        if (!parsedRequest) {\n            throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\n        }\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n\n        // Get cached authority and use if no authority is cached with request.\n        if (StringUtils.isEmpty(parsedRequest.authority)) {\n            const authorityCacheKey: string = this.generateAuthorityKey(state);\n            const cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n            if (!cachedAuthority) {\n                throw BrowserAuthError.createNoCachedAuthorityError();\n            }\n            parsedRequest.authority = cachedAuthority;\n        }\n\n        return parsedRequest;\n    }\n\n    isInteractionInProgress(matchClientId?: boolean): boolean {\n        const clientId = this.getInteractionInProgress();\n\n        if (matchClientId) {\n            return clientId === this.clientId;\n        } else {\n            return !!clientId;\n        }\n    }\n\n    getInteractionInProgress(): string | null {\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        return this.getTemporaryCache(key, false);\n    }\n\n    setInteractionInProgress(inProgress: boolean): void {\n        // Ensure we don't overwrite interaction in progress for a different clientId\n        const key = `${Constants.CACHE_PREFIX}.${TemporaryCacheKeys.INTERACTION_STATUS_KEY}`;\n        if (inProgress) {\n            if (this.getInteractionInProgress()) {\n                throw BrowserAuthError.createInteractionInProgressError();\n            } else {\n                // No interaction is in progress\n                this.setTemporaryCache(key, this.clientId, false);\n            }\n        } else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\n            this.removeItem(key);\n        }\n    }\n\n    /**\n     * Returns username retrieved from ADAL or MSAL v1 idToken\n     */\n    getLegacyLoginHint(): string | null {\n        // Only check for adal/msal token if no SSO params are being used\n        const adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\n        if (adalIdTokenString) {\n            this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n            this.logger.verbose(\"Cached ADAL id token retrieved.\");\n        }\n\n        // Check for cached MSAL v1 id token\n        const msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\n        if (msalIdTokenString) {\n            this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\n            this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\n        }\n\n        const cachedIdTokenString = msalIdTokenString || adalIdTokenString;\n        if (cachedIdTokenString) {\n            const cachedIdToken = new IdToken(cachedIdTokenString, this.cryptoImpl);\n            if (cachedIdToken.claims && cachedIdToken.claims.preferred_username) {\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\n                return cachedIdToken.claims.preferred_username;\n            }\n            else if (cachedIdToken.claims && cachedIdToken.claims.upn) {\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\n                return cachedIdToken.claims.upn;\n            }\n            else {\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Updates a credential's cache key if the current cache key is outdated\n     */\n    updateCredentialCacheKey(currentCacheKey: string, credential: ValidCredentialType): string {\n        const updatedCacheKey = credential.generateCredentialKey();\n\n        if (currentCacheKey !== updatedCacheKey) {\n            const cacheItem = this.getItem(currentCacheKey);\n            if (cacheItem) {\n                this.removeItem(currentCacheKey);\n                this.setItem(updatedCacheKey, cacheItem);\n                this.logger.verbose(`Updated an outdated ${credential.credentialType} cache key`);\n                return updatedCacheKey;\n            } else {\n                this.logger.error(`Attempted to update an outdated ${credential.credentialType} cache key but no item matching the outdated key was found in storage`);\n            }\n        }\n\n        return currentCacheKey;\n    }\n}\n\nexport const DEFAULT_BROWSER_CACHE_MANAGER = (clientId: string, logger: Logger): BrowserCacheManager => {\n    const cacheOptions = {\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\n        storeAuthStateInCookie: false,\n        secureCookies: false\n    };\n    return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\n};\n"]},"metadata":{},"sourceType":"module"}